<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Carlos E. Tafur Egido" />
  <meta name="dcterms.date" content="2025-02-08" />
  <meta name="keywords" content="ciencias de la
computación, informática, tipografía, diseño, documentación, documentación
técnica" />
  <meta name="description" content="Documentación sobre Neovim." />
  <title>Documentación sobre Neovim</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "“" "”" "‘" "’"; }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #b3adad; background-color: #1e1e1e; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #e8ba9b; } /* Alert */
    code span.an { color: #627a62; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #a37979; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #a69974; } /* ControlFlow */
    code span.ch { color: #a37979; } /* Char */
    code span.cn { color: #a37979; font-weight: bold; } /* Constant */
    code span.co { color: #627a62; } /* Comment */
    code span.cv { color: #627a62; font-weight: bold; } /* CommentVar */
    code span.do { color: #627a62; } /* Documentation */
    code span.dt { color: #abab96; } /* DataType */
    code span.dv { color: #99998d; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #b3b378; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #627a62; font-weight: bold; } /* Information */
    code span.kw { color: #a69974; } /* Keyword */
    code span.op { color: #adad92; } /* Operator */
    code span.ot { color: #b3b378; } /* Other */
    code span.pp { color: #e8ba9b; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #a37979; } /* SpecialChar */
    code span.ss { color: #a17272; } /* SpecialString */
    code span.st { color: #a17272; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #a17272; } /* VerbatimString */
    code span.wa { color: #506350; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/variables.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/variables/manuales-comp-sci.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/base-mobile-first.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/tablas.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/tabla-contenidos.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/codigo.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/matematicas.css" />
  <link rel="stylesheet" href="./ajustes-pandoc/salida-web/css/desktop.css" />
  <nav id="nav">
    <!--<h2></h2>-->
    <ul id="menu">
    </ul>
  </nav>

  <!--<main>-->
  <input type="checkbox" id="toc-check" />
  <label id="toc-toggle" for="toc-check">ToC</label>
  <script src="/Users/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/javascript/breadcrumbs.js"></script>
  <script src="/Users/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/javascript/abre-cierra-nav-bar.js"></script>
  <script src="/Users/ctafur/Documents/disenno-tipografia/ajustes-pandoc/salida-web/javascript/nameref.js"></script>
</head>
<body>
<div id="breadcrumb"></div>
<header id="title-block-header">
<h1 class="title">Documentación sobre Neovim</h1>
<p class="author">Carlos E. Tafur Egido</p>
<p class="date">02/08/2025</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introducción" id="toc-introducción">Introducción</a>
<ul>
<li><a href="#neovim" id="toc-neovim">Neovim</a></li>
</ul></li>
<li><a href="#gestor-de-plug-ins-nativo"
id="toc-gestor-de-plug-ins-nativo">Gestor de <em>plug-ins</em>
nativo</a></li>
<li><a href="#mejoras-en-la-asincronía-vim.async"
id="toc-mejoras-en-la-asincronía-vim.async">Mejoras en la asincronía:
<code>vim.async</code></a></li>
<li><a href="#mejoras-en-la-interfaz-de-usuario-ui"
id="toc-mejoras-en-la-interfaz-de-usuario-ui">Mejoras en la Interfaz de
Usuario (UI)</a></li>
<li><a href="#api-para-imágenes" id="toc-api-para-imágenes">API para
imágenes</a></li>
<li><a href="#multicursor-y-supermacros"
id="toc-multicursor-y-supermacros">Multicursor y supermacros</a></li>
<li><a href="#historia" id="toc-historia">Historia</a></li>
<li><a href="#mitos" id="toc-mitos">Mitos</a></li>
<li><a href="#conceptos-básicos" id="toc-conceptos-básicos">Conceptos
básicos</a>
<ul>
<li><a href="#línea-de-reposo-del-teclado"
id="toc-línea-de-reposo-del-teclado">Línea de reposo del
teclado</a></li>
<li><a href="#uso" id="toc-uso">Uso</a></li>
<li><a href="#configuración-básica"
id="toc-configuración-básica">Configuración básica</a></li>
<li><a href="#remapeo-de-teclas" id="toc-remapeo-de-teclas">Remapeo de
teclas</a></li>
<li><a href="#configuración-específica-según-el-lenguaje"
id="toc-configuración-específica-según-el-lenguaje">Configuración
específica según el lenguaje</a></li>
<li><a href="#línea-de-estado" id="toc-línea-de-estado">Línea de
estado</a></li>
<li><a href="#word-wrapping" id="toc-word-wrapping"><em>Word
wrapping</em></a></li>
<li><a href="#buffer-ventana-y-pestaña"
id="toc-buffer-ventana-y-pestaña"><em>Buffer</em>, ventana y
pestaña</a></li>
</ul></li>
<li><a href="#variables" id="toc-variables">Variables</a>
<ul>
<li><a href="#portapapeles-del-sistema"
id="toc-portapapeles-del-sistema">Portapapeles del sistema</a></li>
<li><a href="#lista-quickfix" id="toc-lista-quickfix">Lista
<em>quickfix</em></a></li>
</ul></li>
<li><a href="#conceptos-avanzados"
id="toc-conceptos-avanzados">Conceptos avanzados</a>
<ul>
<li><a href="#resaltado" id="toc-resaltado">Resaltado</a></li>
<li><a href="#ejemplos-de-uso-avanzado"
id="toc-ejemplos-de-uso-avanzado">Ejemplos de uso avanzado</a></li>
</ul></li>
<li><a href="#configuraciones-básicas"
id="toc-configuraciones-básicas">Configuraciones básicas</a>
<ul>
<li><a href="#espaciado-americano"
id="toc-espaciado-americano">Espaciado americano</a></li>
</ul></li>
<li><a href="#configuraciones-intermedias"
id="toc-configuraciones-intermedias">Configuraciones intermedias</a>
<ul>
<li><a href="#tree-sitter" id="toc-tree-sitter">Tree-Sitter</a></li>
<li><a href="#lsp" id="toc-lsp">LSP</a></li>
<li><a href="#terminal" id="toc-terminal">Terminal</a></li>
</ul></li>
<li><a href="#acciones-básicas" id="toc-acciones-básicas">Acciones
básicas</a>
<ul>
<li><a href="#modo-remplazar" id="toc-modo-remplazar">Modo
remplazar</a></li>
<li><a href="#recargar-buffer" id="toc-recargar-buffer">Recargar
<em>buffer</em></a></li>
<li><a href="#marcas" id="toc-marcas">Marcas</a></li>
<li><a href="#pliegues" id="toc-pliegues">Pliegues</a></li>
<li><a href="#moverse-por-archivos"
id="toc-moverse-por-archivos">Moverse por archivos</a>
<ul>
<li><a href="#buffers-y-lista-de-argumentos"
id="toc-buffers-y-lista-de-argumentos"><em>Buffers</em> y lista de
argumentos</a></li>
<li><a href="#comando-args" id="toc-comando-args">Comando
<code>:args</code></a></li>
<li><a href="#comando-edit" id="toc-comando-edit">Comando
<code>:edit</code></a></li>
<li><a href="#comando-find" id="toc-comando-find">Comando
<code>:find</code></a></li>
<li><a href="#comando-filter" id="toc-comando-filter">Comando
<code>:filter</code></a></li>
</ul></li>
<li><a href="#buscar" id="toc-buscar">Buscar</a></li>
<li><a href="#movimientos-básicos"
id="toc-movimientos-básicos">Movimientos básicos</a></li>
</ul></li>
<li><a href="#acciones-intermedias"
id="toc-acciones-intermedias">Acciones intermedias</a>
<ul>
<li><a href="#autocompletado" id="toc-autocompletado">Autocompletado</a>
<ul>
<li><a href="#omnicompletion"
id="toc-omnicompletion">Omnicompletion</a></li>
<li><a href="#con-lsp" id="toc-con-lsp">Con LSP</a></li>
</ul></li>
<li><a href="#corrección-lingüística"
id="toc-corrección-lingüística">Corrección lingüística</a></li>
<li><a href="#actuar-sobre-varios-archivos"
id="toc-actuar-sobre-varios-archivos">Actuar sobre varios
archivos</a></li>
<li><a href="#edición-remota" id="toc-edición-remota">Edición
remota</a></li>
<li><a href="#inserción-múltiple" id="toc-inserción-múltiple">Inserción
múltiple</a></li>
<li><a href="#editar-al-final-de-varios-renglones"
id="toc-editar-al-final-de-varios-renglones">Editar al final de varios
renglones</a></li>
<li><a href="#patrones" id="toc-patrones">Patrones</a></li>
<li><a href="#formatear-código" id="toc-formatear-código">Formatear
código</a></li>
<li><a href="#vimgrep" id="toc-vimgrep">Vimgrep</a></li>
<li><a href="#autocompletado-copiando-texto"
id="toc-autocompletado-copiando-texto">Autocompletado copiando
texto</a></li>
<li><a href="#macros" id="toc-macros">Macros</a></li>
<li><a href="#retazos" id="toc-retazos">Retazos</a></li>
<li><a href="#registros" id="toc-registros">Registros</a></li>
<li><a href="#ampliar-la-selección-visual"
id="toc-ampliar-la-selección-visual">Ampliar la selección
visual</a></li>
<li><a href="#configuración-específica-de-proyecto"
id="toc-configuración-específica-de-proyecto">Configuración específica
de proyecto</a></li>
<li><a href="#acciones-avanzadas" id="toc-acciones-avanzadas">Acciones
avanzadas</a></li>
<li><a href="#macro-sobre-regex" id="toc-macro-sobre-regex">Macro sobre
<em>regex</em></a></li>
<li><a href="#deshacer-con-ramas" id="toc-deshacer-con-ramas">Deshacer
con ramas</a></li>
<li><a href="#multicursores"
id="toc-multicursores">Multicursores</a></li>
<li><a href="#autocomandos" id="toc-autocomandos">Autocomandos</a></li>
<li><a href="#task-runners" id="toc-task-runners"><em>Task
runners</em></a></li>
</ul></li>
<li><a href="#lenguajes" id="toc-lenguajes">Lenguajes</a>
<ul>
<li><a href="#tex-y-sus-formatos" id="toc-tex-y-sus-formatos">TeX y sus
formatos</a></li>
</ul></li>
<li><a href="#plug-ins" id="toc-plug-ins"><em>Plug-ins</em></a>
<ul>
<li><a href="#gestión-diy-de-plug-ins"
id="toc-gestión-diy-de-plug-ins">Gestión DIY de
<em>plug-ins</em></a></li>
</ul></li>
<li><a href="#otros" id="toc-otros">Otros</a>
<ul>
<li><a href="#esquemas-de-colores" id="toc-esquemas-de-colores">Esquemas
de colores</a></li>
<li><a href="#ctags" id="toc-ctags">Ctags</a></li>
<li><a href="#dap" id="toc-dap">DAP</a></li>
<li><a href="#herramientas" id="toc-herramientas">Herramientas</a></li>
<li><a href="#configuración"
id="toc-configuración">Configuración</a></li>
<li><a href="#demasiado-eficiente"
id="toc-demasiado-eficiente">Demasiado eficiente</a></li>
<li><a href="#neovim-vs.-shell" id="toc-neovim-vs.-shell">Neovim
<em>vs.</em> <em>shell</em></a></li>
<li><a href="#neovim-vs.-vscode" id="toc-neovim-vs.-vscode">Neovim
<em>vs.</em> VSCode</a></li>
<li><a href="#plantillas" id="toc-plantillas">Plantillas</a></li>
<li><a href="#configuración-para-todo-el-sistema"
id="toc-configuración-para-todo-el-sistema">Configuración para todo el
sistema</a></li>
<li><a href="#concealing"
id="toc-concealing"><em>Concealing</em></a></li>
<li><a href="#editar-documentación" id="toc-editar-documentación">Editar
documentación</a></li>
<li><a href="#gestión-minimalista-de-archivos"
id="toc-gestión-minimalista-de-archivos">Gestión minimalista de
archivos</a></li>
</ul></li>
</ul>
</nav>
<section id="introducción" class="level1">
<h1>Introducción</h1>
<p>Un editor o IDE que pueda encontrarse en distintos <em>modos</em>
(<em>modes</em>) de edición se suele decir que es un <em>editor
modal</em> (<em>modal editor</em>). En cada modo, las pulsaciones de
teclas, o las combinaciones de estas, producirán una acción distinta.
Muchas de estas no consisten en insertar texto, sino realizar
movimientos del cursor, selecciones, borrar palabras, etc. La
alternativa a los editores modales son los editores no modales
(<em>modeless editors</em><a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a>), que se caracterizan
por encontrarse siempre en un único modo, sin poder cambiar a otro. Lo
normal es que, en los no modales, las pulsaciones de teclas suelen
insertar texto y cualquier otra función se suele hacer con atajos de
teclados (<em>shortcuts</em>), es decir, combinaciones de teclas
modificadoras (por ejemplo, <kbd>Alt</kbd> o <kbd>Ctrl</kbd>) con teclas
normales. Un editor no modal, por tanto, está más limitado que uno modal
en cuanto a las posibilidades de edición con el teclado.</p>
<p>En cierto modo, usar un editor modal es como usar un lenguaje para
editar. Es un lenguaje que no le muestra en pantalla código, sino que
irá viendo en el editor los efectos de lo que codifica. Quizás su
primera impresión sea que esto es demasiado cargante —hacer uso de dos
lenguajes a distintos niveles simultáneamente para escribir el código en
el editor—, y, efectivamente, la curva de aprendizaje de los editores
modales es algo escarpada, pero, cuando ha interiorizado ese lenguaje
para la edición —ha logrado crear la <em>muscle memory</em> que
requiere—, será capaz de editar a una velocidad increíble.</p>
<p>Además, los modos son generativos y flexibles, es decir, a partir de
un conjunto limitado de recursos, se pueden generar una cantidad de
acciones casi ilimitada, ya que se pueden combinar entre sí; al
contrario de lo que sucede con los editores no modales, en los que no
tiene sentido generar atajos de teclado nuevos a partir de la
combinación de otros básicos.</p>
<p>El primer editor modal TKTK fue Vi, un editor TUI creado por Bill Joy
en 1976, TKTK. No es extraño que en esa época surgiese un editor modal,
pues, aunque la empresa Xerox había presentado ya un computador con
funcionalidades GUI, aún no se vendía ningún computador así. Un editor
modal proporcionaba una gran ergonomía para editar archivos dentro de un
terminal (o emulador de terminal).</p>
<p>En 1991, el programador Bram Moolenaar creó, a partir de una
bifurcación de código (<em>fork</em>) de Vi, Vi Improved, que es más
conocido por su contracción: <a href="https://www.vim.org/">Vim</a>.
Este es el editor que realmente popularizó los editores modales.
Moolenaar realizó un gran trabajo, tanto en su <q>ergonomía</q> —gracias
a los modos— como en la propia implementación del <em>software</em>;
llegando incluso a crear un lenguaje propio, conocido como Vimscript,
para la configuración del mismo, lo cual también terminó haciendo que se
pudiesen usar <em>plug-ins</em> (algo similar a las extensiones en otros
editores e IDEs).</p>
<p>En parte, algo que impulsó muchísimo la popularización de Vi y Vim
fue que gran parte de los servidores tipo Unix (Linux, Solaris, etc.) lo
traen instalado de serie. Por tanto, es muy probable que como
administrador de sistemas encuentre que debe acceder a un servidor que
tiene instalado aluno de estos dos. Y, como quizás sepa, los sistemas
tipo Unix suelen seguir la filosofía de que los ajustes del sistema se
hagan manipulando archivos.<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a> Por tanto, saber usar
estos editores es una habilidad que se suele valorar en el mundo de la
administración de sistemas.</p>
<p>Existen otros editores que se basan también en los modos de Vim.
Algunos son <em>forks</em> del propio Vim, que surgieron por
discrepancias sobre el modo de gestionar el proyecto por Moolenaar; al
parecer, era bastante dictatorial<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a>, aunque esto a veces es
bueno en los proyectos de <em>software</em> con licencias <em>open
source</em>.</p>
<p>En cierto modo, tiene bastante sentido que el desarrollador que más
dedicación ha puesto en un proyecto sea muy selectivo a la hora de
aceptar las contribuciones de otros. Me viene a la mente, por ejemplo,
una entrevista que escuché a Brendan Eich, el creador de JavaScript, en
la que explicaba que muchas de las partes muy criticadas de dicho
lenguaje se deben a que fue demasiado permisivo en un principio al
aceptar la solicitudes TKTK.</p>
<p>Existen varios proyectos de gran éxito en las ciencias de la
computación que se podría decir que son dirigidos por algún BDFL. Es el
caso, por ejemplo, del lenguaje Python, por parte de Guido Van Rossum, o
Linux, por Linux Torvalds. TKTK.</p>
<p>El <em>fork</em> más popular de Vim es <a
href="https://neovim.io/">Neovim</a>, que es al que se dedica este
documento. Neovim, como proyecto de <em>software</em>, es dirigido de un
modo más acorde a los tiempos modernos, haciendo uso de herramientas
como GitHub, etc. También, cuenta con integración con tecnologías
modernas para una edición más <q>inteligente</q> (<em>smarter</em>),
como LSP y Tree-Sitter, que lo hacen acercarse más a un IDE, aunque solo
en el caso de que el usuario así lo desee.</p>
<p>De todos modos, debe tener en cuenta que Neovim trata de no
<q>separarse</q> en exceso de Vim en su uso básico. Así, si quiere tener
muchas de las funcionalidades modernas que se tienen actualmente, deberá
especificarlas en la configuración o mediante el uso de
<em>plug-ins</em>. Es decir, Neovim de serie es casi como Vim, y esto
seguramente sea así para que, si el usuario se encuentra teniendo que
editar en Vi o Vim, no <q>ande perdido</q>.</p>
<p>Otras herramientas que hacen uso de los modos Vim son simplemente
extensiones o <em>plug-ins</em> de editores o IDEs. En realidad tal y
como explica el desarrollador Gary Bernhardt, <a
href="https://twitter.com/garybernhardt/status/902956444596617216">se
dejan muchas funcionalidades sin implementar</a>, pues los modos de Vim
cuentan con muchísimas funcionalidades, como comprobará por usted mismo
a lo largo de la lectura de este documento.</p>
<p>Un ejemplo de extensiones de modo Vim en un IDE es la de VSCode, que
no suele gustar a los que la han usado. Existe también la integración
del modo Vim en VSCode por medio del propio Neovim. TKTK. En cuanto a la
extensión del modo Vim de Zed, parece que es mucho mejor que la de
VSCode.</p>
<p>Otro aspecto importante de Vim está en que su configuración es
<em>scriptable</em>, es decir, uno mismo puede ampliar las
funcionalidades del propio editor si toca la configuración. Esto hay a
quien le gusta y a quien no. TKTK.</p>
<p>Podemos también mencionar editores modales que usan modos distintos a
los de Vim. Aun así, tienen un uso bastante marginal. El único que
podría destacar es el editor Kakoune. A parte del propio editor Kakoune,
también usa estos modos el editor Helix. Hay quien cree que los modos de
Kakoune tienen mayor coherencia que los de Vim, pero, aunque así fuese,
creo que no aportan prácticamente nada con respecto a los modos Vim.
Además, a este respecto la inercia que tiene el modo Vim creo que hace
que sea muy improbable que pueda llegar a ser sustituido por el modo
Kakoune.</p>
<section id="neovim" class="level2">
<h2>Neovim</h2>
<p>Neovim es un <em>fork</em> de Vim que parece que le ha superado en
ciertos aspectos. Se trata de un proyecto con un ritmo de desarrollo muy
bueno. También, tras la muerte de Moolenaar, en agosto de 2023, el
proyecto Vim parece que <a
href="https://www.youtube.com/watch?v=bopbmRyHQog">ha tenido que
readaptarse</a>, pues, tal y como he explicado antes, el desarrollo del
proyecto era básicamente hecho por Moolenaar, que en todo caso aceptaba
sugerencias; es decir, era muy poco distribuido.</p>
<p>Parece que el desarrollo de Neovim es el que cuenta con más actividad
que el de Vim. Una diferencia importante entre estos está en el lenguaje
de <em>scripting</em> de la configuración. Vim cuenta con un lenguaje
propio, llamado Vimscript, mientras que en Neovim se optó por delegar
esto a un lenguaje ya existente llamado Lua. Se trata de un lenguaje con
algunas peculiaridades. Lua se suele usar como lenguaje dinámico dentro
de otro lenguaje, es decir, como lenguaje incrustado (<em>embedded</em>)
dentro de un proyecto de <em>software</em> hecho en otro lenguaje más
estático y <q>pesado</q>. Así, es muy común integrar a Lua dentro de
proyectos de <em>software</em> de C++; por ejemplo, es muy común su uso
de este modo en videojuegos.</p>
<p>En el caso de Neovim, este cuenta con una API para usar Lua para la
configuración del mismo, que se corresponde con todas las posibilidades
que da Vimscript y los ajustes del propio Vim.</p>
<p>Lua y Neovim comparten la filosofía de <q>navegar la ola</q>, como ha
dicho en varias ocasiones Justin Keyes, el que se podría decir que es
quien dirige el desarrollo de Neovim. (En realidad, creo que Neovin lo
ha copiado de Lua.) Esto se refleja, por ejemplo, en la elección de Lua
como sustituto de Vimscript; así, no tienen que mantener el desarrollo
de un lenguaje paralelamente al de un editor. También se refleja en
otras decisiones de Neovim, como en el uso de ciertas bibliotecas
(<em>libraries</em>) de <em>software</em> de tipo <em>open source</em>
que existe de forma independiente para sistemas, en lugar de
implementarlas por sí mismo, como sucede en Vim; al menos, sucedía en la
época de Moolenaar. Quizás ahora hayan hecho una refactorización como
Neovim a este respecto. A decir verdad, esto quizás se deba a que ni
siquiera existían esas bibliotecas cuando Moolenaar las implementó.</p>
<p>Por cierto, el proyecto Neovim ha dedicado bastante esfuerzo en que
este siga siendo compatible con los <em>plug-ins</em> de Vim, incluso
los modernos (versión 9 de Vimscript), lo cual es un ejemplo más de esa
filosofía.</p>
<p>Por cierto, en lo que respecta a los <em>plug-ins</em>, algo que debe
tener en cuenta es que lo que sería aconsejable es no abusar de su
poder. Es decir, existen muchos <em>plug-ins</em> que trastocan
completamente el uso del propio Vim o Neovim. Esto va en contra de la
filosofía de TKTK. Además, si, por cualquier cosa, tiene que volver a
usar temporalmente un Vim puro, TKTK.</p>
<p>Esto es algo de lo que se han dado cuenta los principales
desarrolladores de Vim y Neovim, como Tim Pope y TKTK. Mi impresión es
que debido a eso no suelen usar muchos <em>plug-ins</em>.</p>
<p>Aunque Vim y Neovim cuenten con una curva de aprendizaje algo
elevada, con cierto nivel de manejo de estos ya se es capaz de apreciar
por qué son tan elogiados por mucha gente, en lo que respecta a la
usabilidad; también puede llamarlo <q>ergonomía</q>, si lo prefiere.</p>
<p>Una muy buena introducción a Vim y Neovim es <a
href="https://danielmiessler.com/p/vim/"><em>Learn Vim For the Last
Time: A Tutorial and Primer</em></a>, de Daniel Miessler.</p>
<hr />
<p>Los editores basados en modos otorgan, a quien tiene la paciencia de
practicar y desarrollar cierta destreza en su manejo, una velocidad de
edición increíble. Quizás, no tanto como la estenografía
(<em>stenography</em>), pero no creo que esta sea una buena herramienta
para programar; solo es útil para texto corrido; no para ediciones
saltando entre partes distintas.</p>
<p>Un inconveniente que tienen tanto Vim como Neovim es que se trata de
editores que de serie tienen muchas carencias, desde el punto de vista
actual. Es decir, muchas de las funcionalidades que se dan por sentadas
a día de hoy en los IDEs, en Vim y Neovim deberá añadirlas mediante
algún <em>plug-in</em> o configurándolas por usted mismo. Esto se debe a
que siguen una filosofía más de tipo bazar, en oposición a los proyectos
de tipo catedral, según la dicotomía presentada en los 90 por TKTK.</p>
<p>Para poder ser tan versátil, su configuración se tiene que hacer, en
parte, mediante <em>scripting</em>, cosa que a mucha gente no le gusta.
TKTK.</p>
<p>A este respecto, tengo sentimientos enfrentados y no tengo una
opinión bien formada. En Vim y Neovim, al final, en cierto modo,
terminará transformándolo y personalizándolo en parte. Por un lado, a
mucha gente le gusta que se les dé una herramienta con sus usos ya
establecidos; no una que tenga un componente considerable de
configuración y personalización.<a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a> Es decir, eso de
<q><em>convention over configuration</em></q>.</p>
<p>Por otro lado, se puede considerar que con lo que trae el editor Vim
o Neovim de serie es suficiente. Que todo lo demás es accesorio y no
aporta gran cosa. Por ejemplo, quien dirige actualmente el proyecto
Neovim, el programador Justin Keyes, hace, por lo que veo, un uso
bastante minimalista de este. Otra persona relevante en el mundo de la
programación que hace un uso bastante minimalista de Vim es Mitchell
Hashimoto.</p>
<p>También, existen muchos grandes programadores, como George Hotz o
John Carmack, que casi no le dan importancia a las herramientas que
usan. TKTK. Es cierto que no han llegado a usar Vim o Neovim durante
mucho tiempo y que actualmente usan IDEs, pero TKTK.</p>
<p>Esto demuestra que no es necesario ser un <q>mago</q> o un
<em>power-user</em>” de las herramientas que usa uno para ser un
programador de primer nivel.</p>
<p>Sí que es cierto que muchos <em>plug-ins</em> de Vim y Neovim han
roto en parte con la filosofía de estos, y esto no es deseable.<a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a> Es decir, lo ideal es que los
<em>plug-ins</em> se adapten a Vim y Neovim y no modifiquen ciertos
principios de usabilidad de dichos editores. Buen ejemplo de
<em>plug-ins</em> que respetan al editor son los creados por el
desarrollador Tim Pope, bastante popular en el ecosistema de los
<em>plug-ins</em> de Vim.</p>
<p>Dicho esto, la mayoría de la gente usa, en mayor o menor medida,
<em>plug-ins</em> en su uso de Vim y Neovim. La ventaja de Neovim, con
respecto a Vim, está en que los <em>plug-ins</em> se hacen en el
lenguaje Lua, que es bastante más maduro que Vimscript.<a href="#fn6"
class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>
Además, así no se duplican esfuerzos en el proyecto, al no tener que
estar desarrollando, en paralelo al propio editor, un lenguaje. Tal y
como mencioné antes, esto es coherente con la filosofía de Neovim, que
el propio Keyes ha mencionado en alguna conferencia. A veces lo
sintetiza diciendo la frase <q>navegar la ola</q>. Es decir, aprovechar
el <em>software</em> que ya existe, sin tener que reimplementarlo.
Simplemente, integrándose con este. Por ejemplo, integrándose con
algunos IDEs como VSCode, con algunos navegadores web, etc.</p>
<hr />
<p>En realidad, Neovim no dista mucho de Vim. De hecho, es muy
recomendable obtener un conocimiento algo avanzado de Vim, antes de
pasarse a usar Neovim. Sobretodo, de su configuración.</p>
<p>El mejor tutorial que he encontrado sobre la configuración avanzada
de Vim es <a
href="https://www.youtube.com/watch?v=JFr28K65-5E">este</a>.</p>
<hr />
<p>George Hotz hablando de por qué prefiere a VSCode.</p>
<p><a href="https://www.youtube.com/watch?v=bf8E8zSZTtE&amp;t=5006s"
class="uri">https://www.youtube.com/watch?v=bf8E8zSZTtE&amp;t=5006s</a></p>
<p>La cuestión de fondo quizás está, en su caso, en que es preferible
que los creadores de la herramienta sean quienes te impongan su forma de
uso, en lugar de usar un montón de <em>plug-ins</em>. Algo así explicaba
Lea Verou. Es también un poco la filosofía que sigue la empresa Apple
con sus productos. A esto lo suelen llamar <q>convention over
configuration</q>.</p>
<p>Por ejemplo, Hotz lo explica también en una entrevista con Lex
Fridman.</p>
<p><a
href="https://www.reddit.com/r/ThePrimeagenReact/comments/14mpdke/george_hotz_lex_fridman_discussing_copilot_code/"
class="uri">https://www.reddit.com/r/ThePrimeagenReact/comments/14mpdke/george_hotz_lex_fridman_discussing_copilot_code/</a></p>
<hr />
<p>Pero ¿por qué Neovim? La gente que suele elegir Vim o Neovim para
programar suelen hacer un uso bastante minimalista y con control de
TKTK. Por ejemplo, <a
href="https://www.youtube.com/watch?v=rysgxl35EGc">es el caso de
Mitchell Hashimoto</a>, el creador de Terraform.</p>
<hr />
<p>Quizás, el mejor tutorial sobre una configuración sea actualmente el
titulado <a href="https://www.youtube.com/watch?v=x__SZUuLOxw"><em>My
Entire Neovim Setup From Scratch After 8 Years</em></a> del canal de
YouTube DevOps Toolbox. En realidad, este hace referencia a varios
tutoriales sobre las distintas partes.</p>
<p>En cualquier caso, yo actualmente suelo usar una configuración muy
minimalista de Neovim.</p>
<hr />
<p>Cuando se adentra en Neovim, lo normal es que le abrume la enorme
cantidad de <em>plug-ins</em> y configuraciones que realizan muchos
usuarios. Esto se junta con la sensación que solemos tener todos
inicialmente de que a Neovim le faltan muchas cosas con las que cuentan
de serie otros editores e IDEs. Llegado un punto, si aprende lo básico
de Vim o Neovim, se dará cuenta de que puede hacer un uso muy eficiente
del mismo sin necesidad de muchas configuraciones y <em>plug-ins</em>.
Yo actualmente hago un uso muy minimalista de Neovim.</p>
<hr />
<p>Tal y como dice Bram Moolenaar.</p>
<blockquote>
<p>Software development is much more of a craft. A craftsman uses
whatever tools he thinks will get the best result, no matter if they are
what everybody else is using or something different. And a good
craftsman makes his own tools when needed.</p>
</blockquote>
<hr />
<p>Referencia sobre la historia de Vim: <a
href="https://www.youtube.com/watch?v=_2y6vZna6fU"
class="uri">https://www.youtube.com/watch?v=_2y6vZna6fU</a></p>
<hr />
<p>Algo que quizás pueda llegar a ser el futuro sería que Neovim
terminara separándose en algo como <a
href="https://kindavim.app/">KindaVim</a> y el propio editor Neovim que
funcione sobre este.</p>
<p>Novedades en Neovim 0.12</p>
<p>La versión 0.12 de Neovim, aunque todavía en desarrollo, se perfila
como un lanzamiento fundamental bajo el lema <q>El año de Nvim Out of
the Box (OOTB)</q>. El objetivo es mejorar significativamente la
experiencia de usuario desde el primer momento, preparando el terreno
para la futura versión 1.0.</p>
<p>A continuación, se describen algunas de las características y mejoras
más esperadas.</p>
</section>
</section>
<section id="gestor-de-plug-ins-nativo" class="level1">
<h1>Gestor de <em>plug-ins</em> nativo</h1>
<p>Una de las adiciones más anticipadas es un gestor de
<em>plug-ins</em> integrado en el propio Neovim. Esto podría simplificar
enormemente la instalación y gestión de <em>plug-ins</em>, eliminando la
necesidad de gestores de terceros, como lazy.nvim, para configuraciones
sencillas.</p>
</section>
<section id="mejoras-en-la-asincronía-vim.async" class="level1">
<h1>Mejoras en la asincronía: <code>vim.async</code></h1>
<p>Se introducirá una nueva abstracción para tareas asíncronas con
<code>vim.async</code>. Esto proporcionará una base más sólida y
estructurada para la concurrencia, permitiendo que los <em>plug-ins</em>
y la propia configuración manejen operaciones en segundo plano de forma
más eficiente y robusta.</p>
</section>
<section id="mejoras-en-la-interfaz-de-usuario-ui" class="level1">
<h1>Mejoras en la Interfaz de Usuario (UI)</h1>
<p>Se planean varias mejoras en la interacción con la interfaz de
usuario:</p>
<ul>
<li><p><strong>Comando <code>:restart</code></strong>: Permitirá
reiniciar el servidor de Neovim sin necesidad de cerrar y reabrir el
cliente. Esto facilitará la aplicación de cambios en la configuración de
manera casi instantánea.</p></li>
<li><p><strong>Eliminación del mensaje <q>Press ENTER</q></strong>: Se
buscará reducir las interrupciones que pausan el flujo de trabajo y
requieren que el usuario presione la tecla <kbd>Enter</kbd> para
continuar.</p></li>
</ul>
</section>
<section id="api-para-imágenes" class="level1">
<h1>API para imágenes</h1>
<p>Se está desarrollando una nueva API estándar para manejar y mostrar
imágenes directamente en los <em>buffers</em> de Neovim, abriendo la
puerta a nuevas funcionalidades en visores de archivos,
previsualizaciones y otros <em>plug-ins</em>.</p>
</section>
<section id="multicursor-y-supermacros" class="level1">
<h1>Multicursor y supermacros</h1>
<p>Se esperan mejoras en la funcionalidad de multicursor nativa y en el
sistema de macros, permitiendo ediciones complejas de manera más fluida
e intuitiva.</p>
<p>En lo que respecta a las fuentes de información, se tiene la
documentación oficial del proyecto Neovim. En gran parte de las entradas
de esta documentación, hacen referencias a lo que llaman <q>el
manual</q>, que es el tutorial que creó Bram Moolenaar, el creador de
Vim. De hecho, muchas de las partes están muy bien explicadas en este.
Puede enceontrarlo <a
href="https://neovim.io/doc/user/usr_toc.html#user-manual">aquí</a>.</p>
</section>
<section id="historia" class="level1">
<h1>Historia</h1>
<p>Tal y como hemos dicho, Neovim surgió como bifurcación de Vim (Vi
Improved), creado por Bram Moolenaar, en 1991, que es a su vez una
bifurcación de Vi, creado en 1976 por Bill Joy, una persona muy
relevante en la historia de las ciencias de la computación. Aun así, Vi
era un editor bastante simple que surgió de forma natural debido a las
limitaciones del <em>hardware</em> de la época: no se habían inventado
el ratón ni la interfaz gráfica de usuario. Vim sí supuso un salto
grande en cuanto a la cantidad de funcionalidades y lo cierto es que la
interfaz de uso mediante modos (<em>modes</em>) de Vim son una auténtica
genialidad.</p>
<p>Aun así, llegó un punto en el que Vim se quedó bastante obsoleto en
comparación con otros editores modernos como Sublime Text y <a
href="#vscode">Visual Studio Code</a> (VSCode), además de que el modo en
que Moolenaar dirigía el proyecto era bastante <q>dictatorial</q> y
ponía muchas pegas a las propuestas para modernizarlo. Por ejemplo,
modernizar la base del código, pues había partes que podrían sustituirse
por bibliotecas de C, en lugar de ser implementadas por el propio
editor. También, eliminar el soporte para ciertas arquitecturas
obsoletas como, por ejemplo, Amiga. Estas fueron las principales
motivaciones para la creación de Neoivm.</p>
<p>Tras esta adaptación inicial, Neovim pasó a centrarse más en adoptar
LSP y Tree-Sitter, unas tecnologías modernas de editores e IDEs que
básicamente hacen que el editor sea más <q>inteligente</q>. Por ejemplo,
antes, para renombrar una variable, tenía que tener en cuenta que lo que
estaba renombrando en realidad era esa coincidencia (<em>match</em>) de
texto, como mucho, usando una expresión regular; ahora, gracias a esa
<q>inteligencia</q>, puedo ordenar que se renombre a un objeto en
particular, sin el problema de que haya coincidencias parciales con
otros identificativos en el código o con partes de cadenas.</p>
<p>Las cosas interesantes que podría consultar sobre Neovim a partir de
sus propias fuentes de información, son <code>:help msgpack-rpc</code>,
<code>:help nvim-features</code>. Es interesante también una herramienta
de diagnóstico que trae de serie: <code>:checkhealth</code>.</p>
<p>Las versiones de Neovim anteriores a la 0.5 se centraron en
refactorizar el código de Vim para adaptarlo a los nuevos tiempos, así
como la integración de Lua como lenguaje de apoyo, sustituyendo así a
Vimscript donde se pueda. A partir de la versión 0.5, los proyectos
comenzaron a diverger.</p>
<p>Entre las principales funcionalidades que trata de implementar Neovim
(con respecto a Vim), está que Lua sea un lenguaje tan importante para
las extensiones y la configuración como lo es Vimscript. La razón
principal está en que Vimscript es muy lento y tampoco es que sea un
gran lenguaje. A partir de dicha versión, se podrá usar Lua en el
archivo de configuración de Neovim. Es decir, si antes usaba el archivo
<em>init.vim</em> para cargar extensiones y hacer ajustes, ahora podrá
convertirlo a un archivo <em>init.lua</em>, con las ventajas que trae
esto. También, dentro de archivos de Vim, puede introducir partes de
código Lua.</p>
<p>Para aprender cómo usar Lua para Neovim, puede consultar <a
href="https://neovim.io/doc/user/lua.html">la entrada al respecto</a> en
la documentación oficial de Neovim.</p>
<p>Hay que mencionar también que, en Agosto de 2023, falleció Bram
Moolenaar, con lo que creo que la dirección del proyecto Vim se
encuentra actualmente en el aire.</p>
</section>
<section id="mitos" class="level1">
<h1>Mitos</h1>
<p>La mayoría de la gente piensa que lo que gusta de Neovim a sus
partidarios son cosas como lo de moverse con las teclas <kbd>h</kbd>,
<kbd>j</kbd>, etc. y otra serie de cosas. En realidad, no es solo eso.
Vim (así como Neovim) cuenta con ciertas genialidades a la hora de
editar, como, por ejemplo, <a
href="#actuar-sobre-varios-archivos">realizar una acción sobre una lista
de argumentos</a>, <a href="#deshacer-con-ramas">deshacer con ramas</a>,
etc. y hacerlo siempre desde el teclado de forma cómoda y rápida.</p>
</section>
<section id="conceptos-básicos" class="level1">
<h1>Conceptos básicos</h1>
<section id="línea-de-reposo-del-teclado" class="level2">
<h2>Línea de reposo del teclado</h2>
<p>Aunque quizás conozca algunos tipos de teclados ergonómicos, en
realidad, los teclados normales tienen algo de ergonomía. Es decir, tal
y como se explica en la <em>mecanografía</em> (<em>touch typing</em>),
existen formas <q>correctas</q> de escribir con el teclado. Un concepto
importante a este respecto es el de la <em>línea de reposo</em>
(<em>home row</em>; o, si lo prefiere, <em>renglón de reposo</em>), que
es TKTK.</p>
<p>Pues bien, en el modo Vi, los movimientos más básicos, que serían
como los de las flechas del teclado, se hacen con teclas de la línea de
reposo (para la disposición qwerty, que es la más común). Así, las
teclas <kbd>h</kbd>, <kbd>j</kbd>, <kbd>k</kbd> y <kbd>l</kbd>, en el
modo normal, hacen la función de las flechas para mover el cursor. Para
llegar a las teclas fuera de la línea de reposo, tendrá que realizar un
desplazamiento de línea con sus dedos, lo que hace que esas pulsaciones
sean más incómodas. Por esto, lo ideal se considera que todo esté lo más
cerca posible de la línea de reposo y, cuanto más alejada de esta se
encuentre una tecla, más molesto será pulsarla. Hay quien trata de
evitar esto configurando el <em>remapeo</em> (<em>remaping</em>) de
algunas teclas de uso muy frecuente, para así tenerlas más cerca de la
línea de reposo. Debido a esto, el renglón de las teclas de función
(<kbd>f1</kbd>, <kbd>f2</kbd>, etc.) es un renglón <q>prohibido</q> en
el modo Vi… salvo la tecla <kbd>Esc</kbd>, que es precisamente la tecla
que más se usa en Vim, por razones evidentes, aunque hay quien <a
href="#remapeo-de-teclas">hace un remapeo de otras teclas</a> para que
hagan como <kbd>Esc</kbd>.</p>
<p>Dicho esto, no es el uso de las teclas de la línea de reposo como
alternativa a las flechas lo que hace que el modo Vi sea una maravilla
en cuanto a velocidad y comodidad de uso, sino la composición de
acciones de edición en el modo normal.</p>
<!--
De hecho, con el tiempo, para los movimientos básicos he notado que he ido
usando otras teclas que hacen movimientos parecidos. Por ejemplo,

- [backspace]{.kbd} para ir una posición hacia atrás (en lugar de
  [h]{.kbd}). Esta, al contrario que [h]{.kbd}, le permite ir, desde la
  columna línea de un renglón, al último carácter del anterior.
- (_match_) [Enter]{.kbd} para bajar un renglón, en lugar de [j]{.kbd}. Al
  igual que con [backspace]{.kbd}, estas tienen alguna diferencia sutil.
- [-]{.kbd} para subir al renglón justo encima, en lugar de [k]{.kbd}. En
  realidad, sube al primer carácter del renglón justo encima.

En cualquier caso, creo que esto es cuestión de gustos personales.
-->
<p>Otra cosa que seguramente termine usando más que los movimientos de
un solo carácter son cosas como <kbd>w</kbd>, para saltar al inicio de
la palabra siguiente, <kbd>e</kbd> salto al final de la palabra
siguiente, o <kbd>b</kbd>, salto hacia atrás.</p>
</section>
<section id="uso" class="level2">
<h2>Uso</h2>
<p>Algo que me llamó la atención es que, cuando uno ve a alguien en
algún videotutorial usando Vim o Neovim a un nivel avanzado, casi
siempre se le ve usando algo para moverse rápidamente entre los archivos
del proyecto. Mucha gente usa <em>plug-ins</em>, como <a
href="https://github.com/nvim-telescope/telescope.nvim">Telescope</a>,
que implementan esta funcionalidad muy bien. Aun así, Vim y Neovim traen
ya de serie ciertas funcionalidades de este tipo sin necesidad de
instalar extensiones.</p>
<p>Por ejemplo, viene muy bien el comando <code>:find</code>, para abrir
en un <em>buffer</em> y una ventana algún o algunos archivos, según la
expresión regular que especifique. Para sacar mayor provecho a dicho
comando y usarlo de forma más cómoda, hay quien añade el valor
<code>**</code> a la opción <code>path</code> en el editor. Esa
configuración se puede especificar en Vimscript o en Lua, como casi
todo. En Vimscript, sería</p>
<pre class="vim"><code>set path+=**</code></pre>
<p>mientras que, en Lua,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">path</span> <span class="op">=</span> <span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">path</span> <span class="op">+</span> <span class="st">&quot;**&quot;</span></span></code></pre></div>
<p>De todos modos, yo no modifico de forma global la variable
<code>path</code>. Si deseo hacerlo para algún caso concreto, lo hago
manualmente.</p>
<p>Otras formas de moverse en Neovim, sin hacer uso de algún
<em>plug-in</em>, es mediante el comando <code>vimgrep</code>. TKTK.</p>
</section>
<section id="configuración-básica" class="level2">
<h2>Configuración básica</h2>
<p><a
href="https://www.youtube.com/watch?v=rDRZEd5v3y0&amp;feature=youtu.be"
class="uri">https://www.youtube.com/watch?v=rDRZEd5v3y0&amp;feature=youtu.be</a></p>
</section>
<section id="remapeo-de-teclas" class="level2">
<h2>Remapeo de teclas</h2>
<p>Es común entre la gente que usa Vim o Neovim configurar un remapeado
(o remapeo, <em>remap</em>) de algunas teclas, principalmente, de teclas
modificadoras o de <kbd>Esc</kbd>, que es la tecla que más se usa en Vim
y se encuentra en un lugar algo inaccesible; algo alejada de la línea de
reposo del teclado.</p>
<p>Entre las opciones de remapeo de <kbd>Esc</kbd>, las más populares
son asignarla a <kbd>Bloq May</kbd>, pues es una función que para mucha
gente está ya obsoleta; no para mí. Otra opción es, en modo insertar, la
secuencia <kbd>j</kbd> <kbd>k</kbd>, porque son teclas que están en la
<em>home row</em> y, tanto en español como en inglés, casi no hay
palabras que contengan el dígrafo <em>jk</em>. Esta última opción tiene
un inconveniente: tiene que usarla en modo insertar, tal y como hemos
dicho, por lo que no sirve para salir del modo visual. En ese caso,
tendría que emplear <a
href="https://vi.stackexchange.com/a/22751/22600">otras
alternativas</a>, como, por ejemplo, con la combinación <kbd>Ctrl</kbd>
+ <kbd>c</kbd> o pulsando otra vez <kbd>v</kbd> o <kbd>V</kbd>. En caso
de querer remapear <kbd>Esc</kbd> por <kbd>j</kbd> <kbd>k</kbd>, tendrá
que poner en el archivo de configuración lo siguiente:</p>
<pre class="vim"><code>inoremap jk &lt;esc&gt;
&quot; jk as &lt;Esc&gt; in insert mode; jk as TODO TKTK in terminal
&quot; tnoremap jk &lt;C-\&gt;&lt;C-n&gt;</code></pre>
<p>También, hay quien hace que la secuencia al revés haga de
<kbd>Esc</kbd>, es decir, <kbd>k</kbd> <kbd>j</kbd>.</p>
<p>Otros prefieren remapear la tecla <kbd>Bloq May</kbd> para que tenga
la función de <kbd>Ctrl</kbd>. Por ejemplo, es cómodo para quienes usan
el multiplexor de terminal Tmux cuando hacen que la combinación básica
de este sea <kbd>Ctrl</kbd> + <kbd>a</kbd>. Aun así, esto no me
convence. Hacer que <kbd>Bloq May</kbd> sea una tecla modificadora creo
que no tiene mucho sentido, pues está en un lugar que no es ergonómico,
pues, al acceder a esta, me descoloca la posición de los demás dedos de
la mano izquierda.</p>
<p>También, está la cuestión de la ergonomía. Lo primero que me gustaría
decir es que la disposición qwerty no es nada ergonómica. De hecho, se
ideó para evitar que las TKTK de las máquinas de escribir quedasen
atascadas. Por tanto, por estadística, con la lengua inglesa, lo normal
es que con este tipo de teclados se encuentre continuamente alterando
las teclas TKTK.</p>
<p>Existen otras disposiciones que están alcanzando cierta popularidad,
como la dvorak o la colemak. TKTK. El problema es que, en estas
disposiciones, ya no se tienen juntas las teclas para moverse:
<kbd>h</kbd> <kbd>j</kbd> <kbd>k</kbd> <kbd>l</kbd>. Hay quien no ve en
esto un inconveniente. Dicen que puedes interiorizar rápidamente las
nuevas posiciones de esas teclas. Quizás sea cierto y no haya ninguna
razón por la que esas cuatro teclas tengan que estar juntas. Una
disposición más natural sería con una disposición triangular, como la de
las teclas de flecha del teclado.</p>
<p>También, está la cuestión de los teclados ergonómicos TKTK.</p>
<p>Todo esto, al igual que sucede con el uso de Vim y Neovim, me hace
plantearme si merece la pena configurar algo a mi gusto o, si por el
contrario, debería seguir el lema de <q><em>convention over
configuration</em></q>.</p>
</section>
<section id="configuración-específica-según-el-lenguaje" class="level2">
<h2>Configuración específica según el lenguaje</h2>
<p>Para conseguir cambiar el comportamiento de Neovim haciendo ajustes
dependientes del lenguaje en cuestión para el que está editando, no le
queda otra que hacer uso de los <a
href="#autocomandos">autocomandos</a>. Estos son algo complicados en una
primera aproximación, pero, una vez que aprenda a crear sus propios
autocomandos, podrá crear configuraciones muy versátiles y que le
proporcionen una gestión muy cómoda de Neovim.</p>
<p>Se podría decir que un autocomando es un conjunto de ajustes que se
activan tras cierto evento<a href="#fn7" class="footnote-ref"
id="fnref7" role="doc-noteref"><sup>7</sup></a> (<em>event</em>).
Existen muchos tipos de eventos, como, por ejemplo, abrir un archivo con
un <em>buffer</em>, cerrarlo, etc.</p>
<p>Puede servirle como ejemplo, <a
href="https://blog.lourenci.com/how-to-wrap-long-lines-when-writing-markdown-on-vim/#disqus_thread">esta
explicación</a>.</p>
</section>
<section id="línea-de-estado" class="level2">
<h2>Línea de estado</h2>
<p>Han existido varias extensiones para la línea de estado (<em>status
line</em>). Actualmente, creo que para Neovim la mejor es <a
href="https://github.com/hoob3rt/lualine.nvim"
class="plgin">LuaLine</a>.</p>
<p>Para conocer la sintaxis de la línea de estado en Vim, puede
consultarlo con la ayuda:</p>
<pre class="vim"><code>:help statusline</code></pre>
<p>En cualquier caso, no suelo darle importancia a esta funcionalidad.
De hecho, actualmente no uso ningún <em>plug-in</em> para la línea de
estado, sino que la configuro yo mismo. No es tan vistosa y avanzada
como la que se puede conseguir con algún <em>plug-in</em> pero a mí me
sirve perfectamente.</p>
</section>
<section id="word-wrapping" class="level2">
<h2><em>Word wrapping</em></h2>
<p>Con <em>wrapping</em> nos referimos a el cambio de renglón (también
llamado <em>línea</em>, <em>row</em>) en un párrafo, cuando se trata de
comentarios de código o de texto en algún lenguaje de documentación.
También, se puede considerar <em>wrapping</em> a la disposición en
líneas distintas en código.</p>
<p>Dentro del <em>wrapping</em>, se tienen dos modalidades:</p>
<ul>
<li><p><em>hard-wrapped</em> — cuando se cambia realmente de renglón. En
este caso, se puede comprobar que los números de línea son distintos en
cada línea del texto sobre el que se ha realizado ese ajuste.</p></li>
<li><p><em>soft-wrapped</em> — cuando ese ajuste de texto y esos cambios
de renglón se hacen solo de forma aparente. Lo normal es que ese ajuste
se adapte al <em>viewport</em>. TKTK. En realidad, todo el texto que se
ajusta así, se encuentra en el mismo renglón, cosa que puede comprobar
si muestra los números de línea en el editor: todas esas líneas serán en
realidad la misma.</p></li>
</ul>
<p>El <em>hard-wrapping</em> se podría decir que es una de las varias
funcionalidades que se hacen en el formateado de código (<em>code
formatting</em>). Y de hecho hay muchas herramientas de formateado de
código en las que se puede especificar como parámetro cómo desea que se
realice automáticamente el <em>hard-wrapping</em>. Es el caso, por
ejemplo, de la herramienta Prettier, para diversos lenguajes de la web,
como HTML, JavaScript y Markdown.</p>
<p>Los editores e IDEs enfocados en interfaces GUI no suelen traer de
serie la opción de hacer <em>hard-wrapping</em>, mientras que los que
tradicionalmente han sido de terminal, como Vim y Emacs, sí lo traen.
Los primeros, entonces, la única forma de tenerlo es integrarlo mediante
alguna extensión o por medio de alguna herramienta formateadora de
código, como Prettier, antes mencionada.</p>
<p>En Neovim, para hacer ajuste de texto con <em>hard-wrapping</em>,
puede usar, en modo normal, la secuencia <kbd>g</kbd> <kbd>q</kbd>
<kbd>i</kbd> <kbd>p</kbd>, que lo hará para todo el párrafo de texto en
el que se encuentre el cursor. Puede usar otras variantes con ese mismo
prefijo, <kbd>g</kbd> <kbd>q</kbd>. Por ejemplo, <kbd>g</kbd>
<kbd>q</kbd> <kbd>}</kbd> hará el formateo desde la posición del cursor
hasta la primera línea en blanco que encuentre.</p>
<p>Debe tener cuidado con no confundir el <em>hard-wrapping</em> con el
formateo de código, ya que no son exactamente lo mismo. El formateo se
puede hacer con la tecla <kbd>=</kbd> (signo <em>igual</em>), en modo
normal. TKTK.</p>
<!--
También, puede crear un macro que lo haga automáticamente, que es lo mejor,
pues, si ha editado un párrafo en un editor que no es Vim (o Neovim), no le
valdrá con las opciones que acabo de exponer. Este macro debería pasar a un
solo renglón todo el párrafo (con ayuda de [Shift]{.kbd} + [j]{.kbd}) y
luego, con [g]{.kbd} [q]{.kbd} [q]{.kbd}, se pasaría a ajustarse con
_hard-wrapping_.
-->
<p>Es cierto que he tenido algún problema al ajustar texto cuando tengo
texto que no es continuo y lo pego en un archivo que edito con Vim. Lo
cierto es que no llego a entender del todo el <em>text wrapping</em> con
Vim; tengo que ponerme con eso algún día.</p>
<p>Lo mejor sería consultar esta cuestión <a
href="https://neovim.io/doc/user/usr_25.html">en la ayuda de
Neovim</a>.</p>
<p>El parámetro <code>wrap</code> le dice a Vim que haga el
<em>wrap</em>, es decir, la separación de palabra al final de renglón,
de forma visual únicamente, es decir, que haga <em>soft-wrapping</em>.
<code>linebreak</code> le dice que solo haga el <em>wrap</em> en los
caracteres que se le especifican en la opción <code>breakat</code>. De
forma predeterminada, se tiene con el valor siguiente:</p>
<pre class="vim"><code>breakat= ^I!@*-+;:,./?</code></pre>
<p>donde <code>^I</code> indica el carácter tabulación. Advierta que el
espacio también está, al principio.</p>
<p>Es algo complicado. <a
href="https://stackoverflow.com/a/26015800/7026520">Aquí</a> explican
cómo se hace para que aparezca un símbolo en las líneas de continuación
de un <em>soft-wrapping</em>. En concreto, serviría con algo así:</p>
<pre class="vim"><code>&quot; enable indentation
set breakindent

&quot; indent by an additional 2 characters on wrapped lines, when line &gt;= 40
&quot; characters, put &#39;showbreak&#39; at start of line
set breakindentopt=shift:2,min:40,sbr

&quot; append &#39;⤷&#39; to indent
set showbreak=⤷</code></pre>
<p>Para una configuración en Lua, sería lo siguiente:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Highlights soft wrapping so that I can unset numbering lines. Indents by</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2 additional characters on wrapped lines; when line &gt;= 40 characters puts</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- the showbreak symbol at the left.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">breakindent</span> <span class="op">=</span> <span class="kw">true</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">breakindentopt</span> <span class="op">=</span> <span class="st">&quot;shift:2,min:40,sbr&quot;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">showbreak</span> <span class="op">=</span> <span class="st">&quot;⤷&quot;</span></span></code></pre></div>
<p>Me di cuenta de que no me gustaba el color en el que aparecía ese
símbolo. Creo que <a
href="https://stackoverflow.com/a/8079170/7026520">aquí</a> explican
cómo se cambia ese color.</p>
<p>De este modo, me puedo deshacer de los números de línea, pues los veo
innecesarios. Si quiero orientarme en el documento, lo miraré en la
línea de estado.</p>
</section>
<section id="buffer-ventana-y-pestaña" class="level2">
<h2><em>Buffer</em>, ventana y pestaña</h2>
<p>Una buena explicación de esto la hace TJ Devries en un <a
href="https://www.youtube.com/watch?v=htUMvXINZCA&amp;list=PLep05UYkc6wTyBe7kPjQFWVXTlhKeQejM&amp;index=11">videotutorial</a>.
También, puede leer <a
href="https://medium.com/@paulodiovani/vim-buffers-windows-and-tabs-an-overview-8e2a57c57afa">este
artículo</a> o <a
href="https://www.youtube.com/watch?v=sK6HR9lzgU0&amp;pp=ugUEEgJlbg%3D%3D">este
otro vídeo</a>.</p>
<p>Lo primero que debe saber es que estos tres conceptos en Vim y Neovim
no son exactamente iguales que en los editores e IDEs tradicionales,
como VSCode, por ejemplo.</p>
<p>Tal y como explican en la entrada <code>buffer</code> en la
documentación oficial de Neovim (<code>:h buffer</code>), un
<em>buffer</em> es el texto en memoria de un archivo, aunque no tiene
por qué estar mostrándose en el editor. Por tanto, en una sesión de su
uso de Neovim se pueden tener varios archivos abiertos en
<em>buffers</em>, aunque solo se esté mostrando uno. Se mostrarán en una
<em>ventana</em> (<em>window</em>). Se podría decir que una ventana es
un <em>viewport</em> de un <em>buffer</em>.</p>
<p>Como ve, las ventanas en Vim son un concepto distinto al de las
ventanas en otros editores o IDEs como, por ejemplo, VSCode.</p>
<p>Para ver los <em>buffers</em> que tiene en su sesión de Neovim, puede
usar el comando <code>:ls</code>. En la lista de los que muestra, se ve
en la primera columna un número identificativo. En la tercera, aparece
entrecomillada la ruta del archivo de dicho <em>buffer</em>.</p>
<p>Para que se muestre uno de esos <em>buffers</em> en su ventana
(<em>window</em>) actual de Neovim, podría usar el comando
<code>:buffer</code>, o, simplemente, <code>:b</code>, poniéndole como
argumento el identificativo que corresponda al <em>buffer</em> al que
quiere pasar. Pero más cómodo es usar como argumento parte del nombre
del archivo. Por ejemplo, para moverse al <em>buffer</em> del archivo
<em>makefile</em> del proyecto, bastaría con <code>:b mak</code> (si no
tiene otro archivo en algún <em>buffer</em> cuyo nombre coincida con
<code>mak</code> en alguna parte).</p>
<p>También, puede hacer uso del <em>tab-completion</em> en esto. Por
ejemplo, introduzca <code>:b</code> (advierta el espacio) y pulse la
tecla <kbd>Tab</kbd>. Entonces, irá alternando entre TKTK.</p>
<p>También, puede ir entrando en los directorios si, en una preselección
de uno, introduce un asterisco y sigue haciendo
<em>tab-completion</em>.</p>
<p>También, puede moverse al <em>buffer</em> previo con <code>:bp</code>
(o su forma larga: <code>:bprev</code>) y al siguiente con
<code>:bn</code> (o <code>:bnext</code>). Personalmente, uso esto
bastante a menudo, porque me parece cómodo. También, la salida del
comando <code>:ls</code> le muestra algunas marcas en algunos
<em>buffers</em>; es en la segunda columna. Por ejemplo, la marca
<code>#</code>. Para pasar a dicho <em>buffer</em> basta con poner
<code>:b#</code>. El <em>buffer</em> <code>#</code> es algo curioso y
bastante práctico. Tal y como puede ver en la ayuda del comando
<code>:ls</code>, lo llaman el <em>alternate buffer</em>. Dicho
<em>buffer</em> será el que más veces visite. Personalmente, esto es
algo que me viene muy bien. Por ejemplo, para la tabla de contenidos de
un proyecto de documentación. Al ser el <em>buffer</em> que más
<q>visita</q>, será el <em>alternate buffer</em> sin que siquiera tenga
que asignarle usted ese papel.</p>
<p>Para cerrar un <em>buffer</em>, lo abro en una ventana y, desde ahí,
uso el comando <code>:bde</code> (o su forma larga:
<code>:bdelete</code>).</p>
<p>En realidad, puede ver simultáneamente más de un <em>buffer</em>, es
decir, no hay por qué tener una sola ventana abierta en un momento dado.
Así, por ejemplo, puede dividir la interfaz de Neovim en dos ventanas
verticales que muestren un mismo <em>buffer</em>, o que muestren
<em>buffers</em> distintos; lo que usted prefiera. Aunque lo segundo
quizás haya visto hacerlo, lo primero también puede ser muy útil cuando
se trata de un <em>buffer</em> bastante extenso o con una especie de
índice en su interior.</p>
<p>Cuando entra a Neovim, tendrá abierta una ventana. Si prefiere tener
dos ventanas verticales, tendrá que usar el comando
<code>:vsplit</code>. Si prefiere que se abra una ventana en horizontal,
sería con <code>:hsplit</code>. Para moverse por las ventanas, se usan
atajos de teclados compuestos que usan como prefijo <kbd>Ctrl</kbd> +
<kbd>w</kbd>. Así, por ejemplo, para pasar a la ventana de la derecha,
puede usar <kbd>Ctrl</kbd> + <kbd>w</kbd> <kbd>l</kbd>. Recuerde que la
tecla <kbd>l</kbd> se usa normalmente para moverse a la derecha, así que
estos atajos de teclado tratan de mantener la coherencia con las otras
funciones asociadas a teclas en Neovim. Otro atajo de ventanas que uso
bastante es <kbd>Ctrl</kbd> + <kbd>w</kbd> <kbd>Ctrl</kbd> +
<kbd>w</kbd>, que va cambiando a otra ventana, hasta llegar a la última
y, entonces, volver a la primera. Como el máximo número de ventanas que
uso son 2, este comando me resulta cómodo y fácil de usar sin
pensar.</p>
<p>Para cerrar una ventana, se hace con <code>:q</code> (o su forma
larga: <code>:quit</code>). Debe tener cuidado de que, si solo tiene
abierta una ventana, al usar <code>:q</code> se cerrará el propio
Neovim.</p>
<p>Algo que suelo usar, cuando estoy editando un archivo con bastantes
líneas, es abrir una ventana para algún <em>buffer</em>. Uso el comando
<code>:vsplit</code>. Luego, con <kbd>Ctrl</kbd> + <kbd>w</kbd>
<kbd>Ctrl</kbd> + <kbd>w</kbd> me muevo entre ventanas. Así, puedo ir
<q>saltando</q> entre dos partes bastante separadas de un mismo archivo,
cosa que me hace más cómoda la edición. Otra opción sería el uso de <a
href="#marcas">marcas</a>, pero sería algo más incómoda.</p>
<p>Además, en relación a esto, también existe el concepto de
<em>pestaña</em> (<em>tab</em>). Hace alusión simplemente a la forma de
agrupar las ventanas. Es decir, una pestaña es una agrupación de
ventanas. Como ve, el concepto es algo distinto al de las pestañas de
las aplicaciones de tipo GUI.</p>
<p>Personalmente, no le doy uso a las pestañas del editor. Lo que hago
es usar instancias distintas del editor.</p>
<p>Existen los comandos <code>:tabnew</code>, <code>:tabnext</code>,
<code>:tabprevious</code>, <code>:tabclose</code>, etc., asociados a las
acciones que imagina. El comando <code>:tabnext</code> se puede lanzar
también con la secuencia <kbd>g</kbd> <kbd>t</kbd> en el modo
normal.</p>
<!-- Hacer que desaparezcan las demás ventanas de la vista: `:only`. -->
</section>
</section>
<section id="variables" class="level1">
<h1>Variables</h1>
<p>Las variables se pueden consultar en el modo Ex con</p>
<pre class="vim"><code>:echo &amp;&lt;variable&gt;</code></pre>
<p>donde <code>&lt;variable&gt;</code> debe sustituirse por el nombre de
la variable de Neovim en cuestión. Por ejemplo, podría tratarse de la
variable <code>formatoptions</code>.</p>
<pre class="vim"><code>:echo &amp;formatoptions</code></pre>
<p>También, se puede consultar haciendo uso del comando <code>set</code>
o <code>setlocal</code> pero sin terminar de asignar nada, o asignando
un signo de interrogación. Por ejemplo,</p>
<pre class="vim"><code>:set formatoptions</code></pre>
<p>o</p>
<pre class="vim"><code>:set formatoptions=?</code></pre>
<p>En la API de Lua, se consultaría con</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span><span class="va">lua</span> <span class="op">=</span><span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">formatoptions</span><span class="op">.</span><span class="va">_value</span></span></code></pre></div>
<p>Ese signo igual (<code>=</code>) hace que se muestre el
resultado.</p>
<section id="portapapeles-del-sistema" class="level2">
<h2>Portapapeles del sistema</h2>
<p>En Neovim creo que es más estricto a este respecto. Lo que conviene
hacer es aprenderse las combinaciones de teclas para hacerlo desde el
propio Neovim.</p>
<p>Copiar. Se selecciona en modo visual y se copia con
<code>"+y</code>.</p>
<p>Pegar: <code>"+p</code> o bien <code>"+P</code>. TKTK.</p>
</section>
<section id="lista-quickfix" class="level2">
<h2>Lista <em>quickfix</em></h2>
<p><a href="https://www.youtube.com/watch?v=aKG9uR6LhX4"
class="uri">https://www.youtube.com/watch?v=aKG9uR6LhX4</a></p>
<p>Muy interesante son las secuencias que se han incorporado a partir
del <em>plug-in</em> <code>vim-unimpaired</code>. Se puede mover hacia
adelante y hacia atrás mediante <code>]q</code> y <code>[q</code>.</p>
</section>
</section>
<section id="conceptos-avanzados" class="level1">
<h1>Conceptos avanzados</h1>
<section id="resaltado" class="level2">
<h2>Resaltado</h2>
<p>En cuanto a la terminología, personalmente me gusta llamarlo
<em>resaltado de código</em> (<em>code highlighting</em>) o
<em>resaltado léxico</em> (<em>lexical highlighting</em>), pero hay que
decir que lo que más encontrará es <em>resaltado de sintaxis</em>
(<em>syntax highlighting</em>). Personalmente, prefiero llamarlo
<em>resaltado</em> (<em>highlighting</em>), a secas.</p>
<p>En realidad, actualmente, las reglas de resaltado de código no se
basan solo en la sintaxis, sino que también usan la semántica
(<em>semantics</em>). Por esto no me gusta esta última denominación.
También, hay quien lo llama <em>coloreado de código</em> (<em>code
coloring</em>), pero no me gusta, pues en realidad el resaltado hace
varias cosas a parte de colorear el código; por ejemplo, puede hacer uso
de recursos tipográficos como las itálicas (<em>italics</em>) o la
negrita (<em>boldface</em>).</p>
<p>Puede acceder a la ayuda de Vim sobre esta cuestión con
<code>:help syntax</code>.</p>
<p>Si usa Vim o alguna de sus bifurcaciones en un terminal, es decir, en
su versión CLI (no GUI), quizás se vea limitado a este respecto por el
emulador de terminal (<em>terminal emulator</em>) que esté empleando,
pues los hay que no tienen compatibilidad con los esquemas de colores
(<em>color schemes</em>) con <em>truecolor</em>, como sucede, por
ejemplo, con la aplicación Terminal incluida de serie en macOS. En el
código de los esquemas de colores de Vim, a los colores para
<em>truecolor</em> los llaman <code>gui</code>, mientras que a los
esquemas más limitados los llaman <code>cli</code>. Para especificar a
Vim a que ponga <em>truecolors</em>, se hace con</p>
<pre class="vim"><code>set termguicolor</code></pre>
<p>No he encontrado la forma de hacerlo con la API de Lua.</p>
<p>También está la cuestión de las gramáticas que se emplean, es decir,
las reglas que se siguen para aplicar distintos resaltados a distintas
partes del código.</p>
<p>Aunque pueda parecer algo muy rudimentario, la mayoría de los
editores e IDEs crean esas gramáticas mediante expresiones regulares. Es
el caso, por ejemplo, de VSCode o Sublime Text. También, Vim y Emacs
traen de serie implementada esa funcionalidad mediante expresiones
regulares.</p>
<p>Se podría decir que actualmente el estándar <em>de facto</em> en
cuanto a las gramáticas de resaltado de código son las de TextMate, un
IDE creado por Apple.</p>
<p>Seguramente, <a
href="https://news.ycombinator.com/item?id=13601763">el resaltado de
sintaxis de TextMate sea más completo que el de Vim</a>. Aun así, en
algunos casos es mejor el de Vim, por ejemplo, mediante la extensión
<span class="plgin">VimTeX</span> se tiene una gramática muy buena para
el resaltado de código TeX o LaTeX. También, me pareció mejor el
resaltado de código de los <em>makefiles</em> (los archivos de la
herramienta <code>make</code>).</p>
<p>En cualquier caso, el resaltado mediante expresiones regulares
siempre va a tener muchas carencias. Existe una herramienta que ha dado
vida nueva al resaltado de código. Me refiero a Tree-Sitter, creada por
Max Brunsfeld, uno de los miembros del equipo original del editor Atom,
de la empresa GitHub. Ahora, Brunsfeld está junto a varios excompañeros
de GitHub, creando un editor/IDE llamado Zed que tiene mucho potencial
por lo que veo. Evidenteente, dicho editor también hace uso de
Tree-Sitter.</p>
<p>La mejor explicación sobre Tree-Sitter es, para mí, <a
href="https://www.youtube.com/watch?time_continue=688&amp;v=Jes3bD6P0To">la
que dio el propio Brunsfeld en una conferencia</a>.</p>
<p>Por lo que dice Brunsfeld, la forma de abordar el problema de
Tree-Sitter, respecto a las expresiones regulares, simplifica el
problema y hace más sencillo el desarrollo de esas gramáticas.</p>
<p>La buena noticia es que Neovim es de serie compatible con la
tecnología Tree-Sitter. Creo que, a partir de su versión 0.5, Neovim
cuenta con soporte nativo de Tree-sitter. Aunque no es necesario ningún
<em>plug-in</em> para usar resaltado mediante Tree-Sitter en Neovim, sí
es recomendable el uso de <span
class="plgin"><code>nvim-treesitter</code></span>[], que hace por
nosotros la descarga de los parseadores de Tree-Sitter de los distintos
lenguajes. En cualquier caso, esta también se podria hacer manualmente.
Quizás, la gestión externa de las gramáticas de Tree-Sitter sea más
conveniente si va a usar en su sistema más de un editor compatible con
estas.</p>
<p>Por otra parte, también hay quien piensa que se podría llegar a
implementar la gramática de resaltado de código a partir de LSP, ya que
Neovim trae también soporte nativo para este desde su versión 0.5. Hay
quien cree que es mejor hacerlo por Tree-sitter. En cualquier caso, LSP
suele ser para otras cosas, como, por ejemplo, para
<em>linters</em>.</p>
<p>Tree-Sitter puede usarse, tal y como muestra Brunsfeld en la
presentación referida antes, para hacer ediciones más inteligentes de lo
que permiten los editores tradicionales. Así, por ejemplo, le permite
cambiar el nombre de cierto objeto en particular, independientemente de
que dicho nombre coincida con partes de otros objetos. Es decir, le
permite refactorizar en condiciones. La complejidad en este sentido no
tiene límites.</p>
<p>A este respecto, existe un <em>plug-in</em> de Neovim, relacionado
con <code>nvim-treesitter</code>, que le permite asignar secuencias de
teclas en modo normal a ediciones extrañas del editor, gracias a la
inteligencia de Tree-Sitter. Este <em>plug-in</em> se llama <span
class="plgin"><code>nvim-treesitter-textobjects</code></span>[].</p>
<p>En cualquier caso, conviene explicar también los ajustes de Neovim
para las gramáticas tradicionales, basadas en expresiones regulares,
pues a día de hoy estas conviven con las de Tree-Sitter.</p>
<p>Tal y como se explica <a
href="https://vim.fandom.com/wiki/Creating_your_own_syntax_files">aquí</a>
y <a href="https://superuser.com/a/844060">aquí</a>, el proceso consiste
en dos pasos. Primero, asignar tokens según las reglas de las
expresiones regulares. Tras la asignación de los tokens, se especifican
las reglas de resaltado en función de los diversos tokens.</p>
<p>En lo que respecta a los archivos de resaltado de código, la
explicación la puede encontrar con <code>:help syn-files</code>.</p>
<p>En principio, los archivos de resaltado de código en Neovim se
encuentran en la ruta donde están los archivos de instalación de Neovim.
Por ejemplo, para el sistema operativo macOS, si la instalación de
Neovim se hizo mediante el gestor de <em>software</em> Homebrew, se
encontrarán bajo la carpeta <em>/usr/local/Cellar/neovim/<span
class="ph">nvim_vers</span>/share/nvim/runtime/syntax</em>. Por ejemplo,
el archivo <em>/usr/local/Cellar/neovim/<span
class="ph">nvim_vers</span>/share/nvim/runtime/syntax/cpp.vim</em> es el
que se usa para el resaltado de código C++.</p>
<p>En una instalación mediante el gestor de paquetes Nix, estos se
encontrarían bajo la carpeta <em>/nix/store/<span
class="ph">hash_neovim_vers</span>/share/nvim/runtime/syntax</em>. Ese
<span class="ph">hash_neovim_vers</span> podría ser, por ejemplo, algo
así como <code>h5pc2ffyvacsg4qhw66gkgpjln24jhvr-neovim-0.8.0</code>. En
cualquier caso, esas son carpetas que van cambiando, según la versión.
Lo mejor sería consultar el vínculo simbólico
<em>~/.nix-profile/bin/nvim</em> y, una vez en la carpeta a la que
apunta este, entrar en <em>share/nvim/runtime/syntax</em> (me refiero a
la ruta relativa). Ahí se encuentran todos los archivos de gramáticas
tradicionales de Neovim.</p>
<p>Algunas de estas son también sobrescritas por algún <em>plug-in</em>.
Por ejemplo, <code>vimtex</code> usa un archivo de resaltado de código
distinto al que viene de forma predeterminada con Vim. Aun así, creo que
el que trae Vim de serie es muy bueno. Incluso permite extenderlo para
ciertas sintaxis particulares. Vea
<code>:help mysyntaxfile-add</code>.</p>
<p>Los archivos anteriores se deben dejar tal y como vienen, pues irán
actualizándose con las distintas versiones de Neovim. Los ajustes finos
que desee realizar sobre estos, puede hacerlos tanto en archivos de
configuración bajo <em>/etc</em>, si es para una configuración global
del sistema, o bajo <em>~/.config/nvim</em>, si es para un usuario en
concreto. Así, si crea el archivo <em>~/.config/nvim/syntax.vim</em> o
<em>~/.config/nvim/syntax.lua</em>, TKTK.</p>
<p><a href="https://news.ycombinator.com/item?id=18349013"
class="uri">https://news.ycombinator.com/item?id=18349013</a></p>
<p>Para ver cómo se encuentran configurados los parámetros del resaltado
léxico, basta con usar el comando <code>:highlights</code> sin
argumentos.</p>
<pre class="vim"><code>:highlights</code></pre>
<p>Así, se muestran todos los parámetros tal y como están
actualmente.</p>
<p>Algo de lo que debe ser consciente es de que no todos los esquemas de
colores están pensados para usar Tree-Sitter. TKTK.</p>
<hr />
<p>En el ecosistema de Neovim, existen varios <em>plug-ins</em> para
facilitarle la labor de crear esquemas de colores. Por ejemplo, se
tienen a <a href="https://github.com/rktjmp/lush.nvim">Lush</a> y <a
href="https://github.com/tjdevries/colorbuddy.nvim">Colorbuddy</a>.</p>
<hr />
<p>También está el <a
href="https://github.com/nvim-treesitter/completion-treesitter"><code>completion-treesitter</code></a>.</p>
<hr />
<p>Puede ver una buena <a
href="http://vim.wikia.com/wiki/Creating_your_own_syntax_files">explicación
de los archivos de sintaxis</a>, con ejemplos.</p>
<p>Los archivos de sintaxis para Vim se encuentran bajo el directorio
<em><span class="ph">vimruntime</span>/syntax/</em>, donde el valor de
<span class="ph">vimruntime</span> dependerá de cómo lo instaló. Por
ejemplo, si lo instaló mediante el gestor de paquetes Homebrew, será
<em>/usr/local/Cellar/neovim/<span
class="ph">nvim_vers</span>/share/nvim/runtime</em>.</p>
<p>Por ejemplo, el archivo <em>rst.vim</em> será el que especifique la
sintaxis para los archivos de reStructuredText. Al igual que suele pasar
en los sistemas Unix, existe una jerarquía, normalmente, de 3 niveles,
para los archivos de configuración. Creo que en este caso es como casi
siempre: <em>~/.config/nvim/</em> tiene prevalencia sobre los demás, a
nivel del usuario. Luego, hay uno de configuración para el sistema, en
<em>/etc/</em>, y, finalmente, está el que dije antes, es decir, el del
runtime, que no debe tocarse, pues se modifica con las actualizaciones
de Neovim.</p>
<p>Esto debería cambiar con Tree-sitter TKTK.</p>
<p>Los archivos de indentación, se encuentran bajo <em><span
class="ph">vimruntime</span>/intent/</em>.</p>
<hr />
<p>Algo de lo que debe ser consciente es de que existen ciertos
lenguajes en los que se permite cambiar la sintaxis. Es lo que sucede,
por ejemplo, en LaTeX, por medio del paquete <code>minted</code>, para
el listado de código de programación. Gracias a dicho paquete, usted
puede especificar una regla gramatical con la que insertar parte de un
listado de código. Por ejemplo, puede determinar que todo lo que vaya
entre barras verticales, como <code>|este código|</code> sería como si
hubiese puesto la orden <code>verb+este código+</code>, con el propósito
de que en el documento se muestre algo como <code>este código</code>.
Pues bien, al hacer eso, está creando una regla de gramática nueva del
lenguaje que está usando, es decir, LaTeX. Esto no puede saberlo una
gramática de resaltado, a menos que se lo especifique. Quizás, ahora
esto sí se permita, pues existen herramientas que otorgan lo que se
conoce como el <em>resaltado semántico</em> (<em>semantic
highlighting</em>) TKTK.</p>
<p>Hay quien podría considerar que es un error usar un paquete o
bliblioteca en el que se permita usar una gramática distinta a la del
propio lenguaje. TKTK.</p>
<p>De hecho, a este respecto, en cuanto a la documentación, incluso hay
quien considera que los sistemas de documentación no deberían ser
programables. TKTK.</p>
</section>
<section id="ejemplos-de-uso-avanzado" class="level2">
<h2>Ejemplos de uso avanzado</h2>
<p><a href="https://www.youtube.com/watch?v=wgbvBDR4yxk"
class="uri">https://www.youtube.com/watch?v=wgbvBDR4yxk</a></p>
</section>
</section>
<section id="configuraciones-básicas" class="level1">
<h1>Configuraciones básicas</h1>
<p>En lo que respecta a las configuraciones, es bastante común que la
gente termine copiando trozos de configuraciones de otros sitios o que
directamente se instale <em>plug-ins</em> que son configuraciones para
hacer que Neovim tenga las mismas funcionalidades que tendría un
IDE.</p>
<p>Personalmente, no me gusta eso, por varias razones. Las dos
principales son que, por un lado, al hacer esto está personalizando en
exceso a Neovim, con lo que es como si estuviese usando otro editor
completamente diferente. Además, al hacer eso no avanza en su
aprendizaje de Neovim.</p>
<p>A este respecto, existe un <em>plug-in</em> llamado
<code>kickstart.nvim</code> que es como un punto de partida sobre el que
comenzar a hacer su configuración de Neovim pero sin empezar desde una
base tan básica.</p>
<p>Personalmente, ya ni instalo <code>kickstart.nvim</code>, ya que
estoy tratando de hacer un uso bastante minimalista. Aun así, sí que
configuro ciertas cosas y uso algunos <em>plug-ins</em>.</p>
<p>Quizás, los mejores tutoriales para hacer una configuración básica
sin recurrir a cosas como <code>kickstart.nvim</code> sea la
<em>playlist</em> en YouTube de TJ DeVries titulada <a
href="https://www.youtube.com/playlist?list=PLep05UYkc6wTyBe7kPjQFWVXTlhKeQejM">Advent
of Neovim</a> que hizo a finales de 2024.</p>
<section id="espaciado-americano" class="level2">
<h2>Espaciado americano</h2>
<p>Existe una sutileza que hay quien trata de seguir cuando compone sus
textos. Es el espaciado tras símbolos de final de oración
(<em>sentence</em>): punto (<code>.</code>), cierre de exclamación
(<code>!</code>)<a href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a> y cierre de interrogación
(<code>?</code>). Las dos opciones que existen son:</p>
<!-- También, puntos suspensivos? TKTK -->
<ul>
<li><em>Espaciado americano</em> — El espacio tras ese símbolo de final
de oración aparece con mayor anchura.</li>
<li><em>Espaciado francés</em> — Es igual a los demás espacios.</li>
</ul>
<p>Esto en realidad es algo que se ve en el texto final producido. En
principio, no afectaría al editor de textos, aunque también es cierto
que a veces en texto plano se dejan dos espacios para indicar la
separación de las oraciones. En el editor de textos, si usa un lenguaje
para componer el documento de texto, como, por ejemplo, LaTeX o
Markdown, existen formas de indicar el espacio de fin de oración, pero
no nos interesan aquí.</p>
<p>Por cierto, aunque una de las modalidades sea la americana, en
realidad en América no se suele usar muy a menudo. Lo que más se suele
usar ahora en todo el mundo es el espaciado francés. El espaciado
americano creo que se encuentra con frecuencia en escritos antiguos.</p>
<p>En LaTeX, un punto en el cuerpo de texto normal se corresponderá con
un punto de fin de oración, salvo si la letra anterior al punto es
mayúscula, en cuyo caso la interpretaría como una simple abreviatura.
Sin embargo, si quiere indicar que un punto es un punto de una
abreviatura y no es fin de oración, debe anteponerle el signo de arroba,
<code>@</code>. Por ejemplo, <code>Mr@. nombre</code>. En Markdown,
aunque en realidad dependerá de la variante en concreto de este, lo que
se suele hacer es dejar dos espacios tras el punto si quiere que sea de
fin de oración. Evidentemente, también indica punto de fin de oración el
punto al final de un párrafo.</p>
<p>En mi caso, intenté durante un tiempo usar el espaciado americano,
pues proporciona más información al texto de forma más puramente visual
y, por tanto, más rápida. Al final, desistí, pues, entre otras cosas, no
es compatible con el <em>hard-wrapping</em> (buscar fuente TKTK).
Además, tampoco parece que sea algo que se note en la lengua hablada.
TKTK.</p>
<p>Existe una variable de Vim, llamada <code>joinspaces</code>, que, si
está activada, mantiene de forma subyacente la información de los dos
espacios (espaciado americano) al pasar un párrafo de
<em>soft-wrapped</em> a <em>hard-wrapped</em>, aunque en algunos casos
no muestre los dos espacios, como, por ejemplo, cuando el punto está al
final de un renglón. Esto es algo que no me gusta y es principalmente lo
que me hizo dejar de usar el espaciado americano.</p>
<p>Al usar el espaciado francés, intento no usar abreviaturas de forma
directa, para que los puntos suelan ser de final de oración. Lo que
suelo hacer es usar la directiva de reStructuredText para reemplazar
texto.</p>
<p>Aun así, no deja de parecerme mejor el espaciado americano, y estaría
dispuesto a usarlo si encontrara una solución a su uso con
<em>hard-wrapping</em>. En el caso de espaciado francés, no se distingue
tan fácilmente el espacio de separación de párrafo, pues es igual que el
de una abreviatura (por ejemplo, <code>a.k.a. nombre</code>).</p>
</section>
</section>
<section id="configuraciones-intermedias" class="level1">
<h1>Configuraciones intermedias</h1>
<section id="tree-sitter" class="level2">
<h2>Tree-Sitter</h2>
<p>Tal y como hemos comentado en la sección sobre el [resaltado de
código][], la integración de Tree-Sitter en Neovim es una de las
novedades más interesantes que tiene respecto a Vim.</p>
<p>Un buen tutorial básico sobre cómo configurar Tree-Sitter en Neovim
es <a href="https://www.youtube.com/watch?v=MpnjYb-t12A">el de TJ
Devries</a>.</p>
<p>Para que sea el propio Neovim el que gestione los parseadores
(<em>parsers</em>) de Tree-Sitter, lo mejor es instalar el
<em>plug-in</em> <span
class="plgin"><code>nvim-treesitter</code></span>[], aunque se puede
hacer la gestión externa de los mismos; por ejemplo, instalándolos con
un gestor de <em>software</em> como Homebrew o APT.</p>
<p>La configuración que tengo ahora con este es la siguiente:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span><span class="st">&#39;nvim-treesitter.configs&#39;</span><span class="op">.</span>setup <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">ensure_installed</span> <span class="op">=</span> <span class="op">{</span> <span class="st">&quot;c&quot;</span><span class="op">,</span> <span class="st">&quot;latex&quot;</span><span class="op">,</span> <span class="st">&quot;lua&quot;</span><span class="op">,</span> <span class="st">&quot;python&quot;</span><span class="op">,</span> <span class="st">&quot;json&quot;</span><span class="op">,</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;yaml&quot;</span><span class="op">,</span> <span class="st">&quot;vim&quot;</span><span class="op">,</span> <span class="st">&quot;rst&quot;</span><span class="op">,</span> <span class="st">&quot;markdown&quot;</span><span class="op">,</span> <span class="st">&quot;javascript&quot;</span><span class="op">,</span> <span class="st">&quot;rust&quot;</span><span class="op">,</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;go&quot;</span><span class="op">,</span> <span class="st">&quot;sql&quot;</span><span class="op">,</span> <span class="st">&quot;bash&quot;</span> <span class="op">},</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">sync_install</span> <span class="op">=</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">auto_install</span> <span class="op">=</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">highlight</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">enable</span> <span class="op">=</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="va">indent</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">enable</span> <span class="op">=</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="va">folding</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">enable</span> <span class="op">=</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>También, se puede especificar <code>"all"</code> como valor de
<code>ensure_installed</code>, pero prefiero llevar un control
<q>manual</q> de los que se instalan. También, si lo prefiere, puede
optar por dar el valor <code>"maintained"</code>, para que instale solo
los que tienen un mantenimiento activo.</p>
<p>Si usa el gestor de <em>plug-ins</em> Lazy, los parseadores se
instalarán bajo la carpeta
<em>~/.local/share/nvim/lazy/nvim-treesitter/parser</em>. Los
ejecutables son archivos con extensión <em>.so</em>.</p>
<p>Para forzar la actualización de los parseadores, desde Neovim, puede
usar el comando de Ex <code>TSUpdate</code>. También, a la hora de
añadir el paquete <code>nvim-treesitter</code> al gestor de paquetes,
puede hacerle que ejecute el comando <code>TSUpdate</code> cada vez que
abra Neovim. En el caso del gestor Lazy, se haría así:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="st">&quot;nvim-treesitter/nvim-treesitter&quot;</span><span class="op">,</span> <span class="va">run</span> <span class="op">=</span> <span class="st">&quot;:TSUpdate&quot;</span><span class="op">},</span></span></code></pre></div>
<p>Si delega la gestión de Tree-Sitter al <em>plug-in</em>
<code>nvim-treesitter</code>, este descargará las gramáticas de
Tree-Sitter mediante Node. Por tanto, es un requisito tener Node
instalado en su sistema si desea usar dicho <em>plug-in</em>.</p>
<p>También, la herramienta de línea de comandos
<code>tree-sitter</code>, se puede configurar para especificarle dónde
están los parseadores. Podemos aprovechar los que descarga Neovim con su
<em>plug-in</em>. El archivo de configuración de
<code>tree-sitter</code> es <em>~/Library/Application
Support/tree-sitter/config.json</em>. Personalmente, me gusta cambiar lo
siguiente en dicho archivo.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;parser-directories&quot;</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;/Users/ctafur/github&quot;</span><span class="ot">,</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;/Users/ctafur/src&quot;</span><span class="ot">,</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;/Users/ctafur/source&quot;</span><span class="ot">,</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;/Users/ctafur/.local/share/nvim/lazy/nvim-treesitter/parser&quot;</span><span class="ot">,</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;/Users/ctafur/Documents/editores-de-texto/tree-sitter-parsers&quot;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="er">.</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="er">.</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="er">.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>Pero no me funciona. Intento parsear algún archivo de código y no lo
hace. Por ejemplo,</p>
<pre><code>$ tree-sitter parse mario.c
No language found</code></pre>
<p>aun cuando estoy seguro de que tengo los <em>parsers</em> en las
rutas que le indiqué.</p>
<p>Otra cosa que creo que tiene Tree-Sitter y que me parece muy
interesante es que se pueden hacer ajustes de forma local, es decir,
para un proyecto. Se puede crear el archivo <em>grammar.json</em> bajo
la carpeta <em>src</em>, en la raíz del proyecto.</p>
<hr />
<p>Para analizar los nodos de Tree-Sitter desde Neovim, antes se usaba
un <em>plug-in</em> llamado <code>tree-sitter-playground</code>. Ahora,
el <em>plug-in</em> <code>nvim-treesitter</code> trae de serie los
comandos <code>Inspect</code> e <code>InspectTree</code>. Este último
sería el equivalente a <code>tree-sitter-playground</code>. El otro
muestra solo la información del nodo sobre el que se encuentra el
cursor.</p>
<hr />
<p>Algo de lo que me estoy dando cuenta es de que, aunque desde la
llegada de Neovim estén proliferando mucho los <em>plug-ins</em>, hay
ciertos componentes o <em>plug-ins</em> básicos gracias a los cuales no
se necesitan la mayoría de los demás. Es el caso, por ejemplo, de
Tree-Sitter, que viene integrado de serie con Neovim; aunque es
recomendable gestionarlo mediante un <em>plug-in</em>, pues de lo
contrario es complicado. Tree-Sitter nos permite, si lo conocemos un
poco, hacer selecciones muy inteligentes de partes del código;
selecciones sobre las que podremos realizar acciones de Vim.</p>
<p>Dicho esto, quizás esté llegando el fin de Neovim y estas dos
tecnologías (LSP y Tree-Sitter) terminen haciendo que sea irrelevante.
Quizás, una vez que contemos con esa inteligencia sobre el código que
obtenemos a dichas tecnologías, no necesitemos tantas cosas como nos
proporcionan Vim y Neovim. Esto lo digo porque el <em>plug-in</em>
<code>nvim-treesitter-objects</code> considero que indica el futuro de
la edición de código. El problema con Vim y Neovim está en que no están
estandarizadas las combinaciones de teclas para los distintos objetos
sobre los que actuar. Esto puede hacer también que se interfiera con los
objetos básicos con los que operan Vim y Neovim. Un editor nuevo, como,
por ejemplo, Helix, aun siendo bastante más sencillo que Vim y Neovim,
puede centrarse más en las tecnologías modernas. O quizás lo que termine
usando la gente sea el modo Vim en otros editores o IDEs.</p>
<p>Bueno, quizás en Vim y Neovim se puedan reconfigurar los viejos y
dejar solo los que yo le especifique en la configuración de
<code>nvim-treesitter-objects</code>.</p>
<hr />
<p>También, aunque haya muchas cosas que se pueden hacer directamente
con Vim de forma directa, sin necesidad de <em>plug-ins</em>, es cierto
que las nuevas tecnologías que ha adoptado Neovim, como LSP y
Tree-Sitter, creo que terminarán haciendo que cambie el uso de ciertas
partes de Neovim. El mundo de los editores ha cambiado y hay que
asumirlo. Vim tiene muchas carencias; por ejemplo, en el resaltado de
sintaxis. Tree-Sitter supone una gran evolución a este respecto.</p>
<hr />
<p>Una muestra de las posibilidades que puede dar Tree-Sitter es que <a
href="https://www.youtube.com/watch?v=NcUJnmBqHTY">se está usando en un
lenguaje de edición oral llamado Cursorless</a>.</p>
<hr />
</section>
<section id="lsp" class="level2">
<h2>LSP</h2>
<p>Language Server Protocol, más conocido por sus siglas LSP, es un
estándar abierto creado por Microsoft para suministrar las
funcionalidades típicas de los IDEs como autocompletado de código,
resaltado semántico, etc. Antes de nada, me gustaría advertir de que hay
quien cree (por ejemplo, David Heinemeier Hansson, el creador del
<em>framework</em> Ruby on Rails) que automatizar en exceso la escritura
de código, ya sea mediante <em>snippets</em>, herramientas de AI, etc.,
le convierte en un programador más torpe y conducirá necesariamente a
que cree <em>software</em> de menor calidad.</p>
<p>Volviendo a LSP, lo que le diferencia de otras tecnologías de este
tipo con las que han contado los IDEs desde hace bastantes años ya está
en que, por un lado LSP es una tecnología abierta, y, por otro, que es
una tecnología de tipo cliente-servidor[^Para Jonathan Blow es un
aberración usar servicios para un <em>software</em> con este
propósito.], gracias a lo cual puede ser universal. Es decir, lo único
que requieren los editores o IDEs es un cliente de LSP. Luego, en el
sistema se deben instalar los servidores LSP de los distintos lenguajes
que se desee usar y estos servirían para todos los editores o IDEs con
un cliente de LSP.</p>
<p>Al ser así, se evita tener que reimplementar las funcionalidades LSP
de un lenguaje en concreto para los distintos editores o IDEs. En la web
oficial del proyecto puede encontrar una lista de los principales
servidores LSP. Por cierto, puede que encuentre más de uno para un mismo
lenguaje. Hay quien usa más de uno para un mismo lenguaje, pues puede
que sean complementarios; cada uno especializado en ciertos aspectos. Es
lo que sucede, por ejemplo, con los servidores LSP de Python TKTK.</p>
<p>Actualmente, los principales editores e IDEs de código abierto
cuentan con clientes LSP; por ejemplo, Neovim, VSCode, Emacs, etc.</p>
<p>Aunque Neovim viene con soporte de LSP de serie desde la versión 0.5,
casi todo el mundo usaba algún <em>plug-in</em> como <a
href="https://github.com/neovim/nvim-lspconfig"
class="plgin"><code>nvim-lspconfig</code></a>, pues no era trivial hacer
una configuración a este respecto directamente en la configuración de
Neovim. A partir de la versión 0.11 se puede afirmar que es sencillo
hacer uso de LSP en Neovim sin uso de <em>plug-ins</em>.</p>
<p>En cualquier caso, el <em>plug-in</em> <a
href="https://github.com/neovim/nvim-lspconfig"
class="plgin"><code>nvim-lspconfig</code></a> puede que le venga bien
por comodidad ya que le ofrece una interfaz desde la que puede gestionar
de forma unificada los distintos LSPs; es decir, no tiene por qué ir
<q>batallando</q> con las particularidades de cada uno: qué comando se
usa para uno en concreto, qué <em>root markers</em> especificar para tal
lenguaje, etc. Además, si se fija, se trata de un <em>plug-in</em>
creado por el propio proyecto Neovim, con lo que cuenta con la confianza
de que estará bien hecho. TKTK.</p>
<p>Lo que no hace <a href="https://github.com/neovim/nvim-lspconfig"
class="plgin"><code>nvim-lspconfig</code></a> es instalarle o
actualizarle los servidores LSP. Estos los puede instalar mediante algún
gestor de <em>software</em> de su sistema, como Homebrew o APT; o
incluso instalarlo por usted mismo desde el código fuente (es decir, sin
un paquete precompilado). Si desea que sea el propio Neovim el que se
encargue de instalarlos y gestionarlos, puede usar el <em>plug-in</em>
<em>plug-in</em> <a href="https://github.com/mason-org/mason.nvim"
class="plgin">Mason</a>.</p>
<p>También se puede configurar el autocompletado en Neovim, incluyendo
las funcionalidades de LSP en este, sin necesidad de <em>plug-ins</em>.
Si prefiere hacerlo con algún <em>plug-in</em>, creo que actualmente el
mejor para esto es <a href="https://github.com/Saghen/blink.cmp"
class="plgin"><code>blink.cmp</code></a>.</p>
<p>Puede ver <a
href="https://www.reddit.com/r/neovim/comments/1merz97/hands_down_the_easiest_lsp_setup_for_neovim_012/">este
tutorial</a> sobre cómo se haría una configuración moderna de LSP en
Neovim, aunque sí que usa algunos <em>plug-ins</em>.</p>
<!-- Algunos servidores LSP proporcionan _snippets_, pero no todos. -->
<p>Con el comando <code>:LspInfo</code> puede consultar los clientes LSP
que se encuentran activos (<em>active</em>) en el propio Neovim (el el
proceso). Algunos estarán ligados (<em>attached</em>) a algún o algunos
<em>buffers</em> y otros no (<em>detached</em>). A este respecto,
existen los eventos <code>LspAttach</code> y <code>LspDetach</code>.</p>
<p>Por ejemplo, es muy típico crear un autocomando para lanzar el
formateado de código en el evento <code>LspDetach</code> (vea
<code>:help LspDetach</code>).</p>
<p>Popr ejemplo, con</p>
<pre class="vim"><code>:lua vim.lsp.buf_attach_client(0, 1)</code></pre>
<p>ligaríamos el cliente LSP 1 al <em>buffer</em> en el que nos
encontramos. El id del cliente LSP se puede ver con
<code>LspInfo</code>. De forma análoga se puede hacer
<em>detach</em>.</p>
<hr />
<p>Autocompletado de LSP</p>
<p>Se puede consultar en la documentación oficial de Neovim con
<code>:help lsp-autocompletion</code>.</p>
<p>En principio, si no se ha modificado nada, el autocompletado se lanza
con <kbd>Ctrl</kbd> + <kbd>x</kbd> <kbd>Ctrl</kbd> + <kbd>o</kbd> en el
modo <em>insert</em>. Esto creo que es lo que en Vim llaman <em>omni
completion</em>.</p>
<p>Además del autocompletado básico, si lo configura, puede tener
también autocompletado del servidor LSP que corresponda con ese
<em>buffer</em> en particular.</p>
<p>Se puede crear un autocomando del evento <code>LspAttach</code> para
habilitar (<em>enable</em>) el autocompletado LSP.</p>
<p><a href="https://www.youtube.com/watch?v=tnlgQFQi2s4"
class="uri">https://www.youtube.com/watch?v=tnlgQFQi2s4</a></p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Enables LSP completion &lt;https://www.youtube.com/watch?v=tnlgQFQi2s4&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">api</span><span class="op">.</span>nvim_create_autocmd<span class="op">(</span><span class="st">&quot;LspAttach&quot;</span><span class="op">,</span> <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">group</span> <span class="op">=</span> <span class="va">vim</span><span class="op">.</span><span class="va">api</span><span class="op">.</span>nvim_create_augroup<span class="op">(</span><span class="st">&quot;my.lsp&quot;</span><span class="op">,</span> <span class="op">{}),</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">callback</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">args</span><span class="op">)</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">local</span> <span class="va">client</span> <span class="op">=</span> <span class="fu">assert</span><span class="op">(</span><span class="va">vim</span><span class="op">.</span><span class="va">lsp</span><span class="op">.</span>get_client_by_id<span class="op">(</span><span class="va">args</span><span class="op">.</span><span class="va">data</span><span class="op">.</span><span class="va">client_id</span><span class="op">))</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">client</span><span class="op">:</span>supports_method<span class="op">(</span><span class="st">&quot;textDocument/completion&quot;</span><span class="op">)</span> <span class="cf">then</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>            <span class="va">vim</span><span class="op">.</span><span class="va">lsp</span><span class="op">.</span><span class="va">completion</span><span class="op">.</span>enable<span class="op">(</span><span class="kw">true</span><span class="op">,</span> <span class="va">client</span><span class="op">.</span><span class="va">id</span><span class="op">,</span> <span class="va">args</span><span class="op">.</span><span class="va">buf</span><span class="op">,</span> <span class="op">{</span><span class="va">autotrigger</span> <span class="op">=</span> <span class="kw">true</span><span class="op">})</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span>cmd<span class="op">(</span><span class="st">&quot;set completeopt+=noselect&quot;</span><span class="op">)</span></span></code></pre></div>
<p>El ajuste que aparece al final hace que no se seleccione
automáticamente, cosa que opino que nos entorpece bastante al editar.
Para moverse por el menú desplegable con las distintas posibilidades de
autocompletado puede usar <kbd>Ctrl</kbd> + <kbd>n</kbd> y
<kbd>Ctrl</kbd> + <kbd>p</kbd>, o con las flechar arriba y abajo, si lo
prefiere.</p>
<p>Al moverse por estas, sí se seleccionará en la que se encuentre,
aunque no de forma acumulativa. Otra forma de que se añada al
<em>buffer</em> uno de estos posibles autocompletados del menú
desplegable es con la combinación <kbd>Ctrl</kbd> + <kbd>y</kbd>.</p>
<hr />
<p><em>inlay hints</em></p>
<hr />
<p>La buena noticia es que esto está comenzando ya a cambiar; sobretodo,
desde la versión 0.11. Ahora resulta más cómodo hacer la gestión de LSP
por uno mismo en Neovim. Una explicación bastante buena está en <a
href="https://gpanders.com/blog/whats-new-in-neovim-0-11/">un
artículo</a> del blog de Gregory Anders.</p>
<p>He visto que en YouTube también hay algunos tutoriales a este
respecto, como <a href="https://www.youtube.com/watch?v=bTWWFQZqzyI">el
de TJ DeVries</a>, que no está mal.</p>
<p>Veamos lo básico sobre cómo se configuraría sin <em>plug-ins</em>. El
<em>framework</em> de Lua para la gestión de LSP es
<code>vim.lsp</code>. Por ejemplo, para configurar de forma directa la
comunicación de Neovim con el servidor LSP de Python <code>ruff</code>,
se podría añadir lo siguiente a la configuración:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">lsp</span><span class="op">.</span>start<span class="op">({</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;python-ruff&quot;</span><span class="op">,</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">cmd</span> <span class="op">=</span> <span class="op">{</span> <span class="st">&quot;ruff&quot;</span><span class="op">,</span> <span class="st">&quot;server&quot;</span> <span class="op">},</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">root_dir</span> <span class="op">=</span> <span class="va">vim</span><span class="op">.</span><span class="va">fs</span><span class="op">.</span>dirname<span class="op">(</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">vim</span><span class="op">.</span><span class="va">fs</span><span class="op">.</span>find<span class="op">({</span> <span class="st">&quot;setup.py&quot;</span><span class="op">,</span> <span class="st">&quot;pyproject.toml&quot;</span><span class="op">,</span> <span class="st">&quot;.git&quot;</span> <span class="op">},</span> <span class="op">{</span> <span class="va">upward</span> <span class="op">=</span> <span class="kw">true</span> <span class="op">})[</span><span class="dv">1</span><span class="op">]</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">),</span></span></code></pre></div>
<p>Puede consultar <code>:help vim.lsp.start</code> para aprender el
comportamiento de dicha función.</p>
<p>Tiene que averiguar cuál es el comando con el que se arranca ese
servidor LSP en concreto. En este ejemplo, es <code>ruff server</code>.
Para cada servidor LSP puede ser diferente.</p>
<p>Por cierto, como es evidente, al contrario de lo que sucede con los
<em>plug-ins</em> de LSP, al hacer la gestión de forma directa (es
decir, sin uso de <em>plug-ins</em>), deberá instalar por usted mismo el
servidor LSP en su sistema. Es fácil: se suele encontrar en los
principales gestores de instalación, como Homebrew, APT, Nix, etc.</p>
<p>Lo normal es introducir esa orden de inicio del servidor LSP en un
autocomando, para que se lance únicamente cuando sea necesario. Así,
mejor que lo anterior, sería</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">api</span><span class="op">.</span>nvim_create_autocmd<span class="op">(</span><span class="st">&quot;FileType&quot;</span><span class="op">,</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">pattern</span> <span class="op">=</span> <span class="st">&quot;python&quot;</span><span class="op">,</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">callback</span> <span class="op">=</span> <span class="kw">function</span><span class="op">()</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">vim</span><span class="op">.</span><span class="va">lsp</span><span class="op">.</span>start<span class="op">({</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;python-ruff&quot;</span><span class="op">,</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">cmd</span> <span class="op">=</span> <span class="op">{</span> <span class="st">&quot;ruff&quot;</span><span class="op">,</span> <span class="st">&quot;server&quot;</span> <span class="op">},</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">root_dir</span> <span class="op">=</span> <span class="va">vim</span><span class="op">.</span><span class="va">fs</span><span class="op">.</span>dirname<span class="op">(</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>                <span class="va">vim</span><span class="op">.</span><span class="va">fs</span><span class="op">.</span>find<span class="op">({</span> <span class="st">&quot;setup.py&quot;</span><span class="op">,</span> <span class="st">&quot;pyproject.toml&quot;</span><span class="op">,</span> <span class="st">&quot;.git&quot;</span> <span class="op">},</span> <span class="op">{</span> <span class="va">upward</span> <span class="op">=</span> <span class="kw">true</span> <span class="op">})[</span><span class="dv">1</span><span class="op">]</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">),</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">})</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span></code></pre></div>
<p><strong>Nota sobre Neovim 0.12</strong>: En la versión 0.12 se
introducirá la función <code>vim.lsp.server()</code>, que simplificará
aún más la configuración de servidores LSP. Esta función estará diseñada
para reducir la cantidad de código repetitivo y ofrecer una forma más
declarativa y sencilla de registrar configuraciones de servidores,
basándose en las configuraciones ya conocidas por la comunidad (similar
a como lo hace <code>nvim-lspconfig</code>, pero de forma nativa).</p>
<p>Para comprobar si está todo configurado correctamente, use el comando
<code>:checkhealth lsp</code>.</p>
<hr />
<p><code>:K</code> muestra la documentación sobre el token en el que se
encuentra el cursor.</p>
<p><kbd>Ctrl</kbd> + <kbd>o</kbd> salta hacia atrás en el historial de
posiciones del cursor.</p>
</section>
<section id="terminal" class="level2">
<h2>Terminal</h2>
<p>Referencias:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=ooTcnx066Do"
class="uri">https://www.youtube.com/watch?v=ooTcnx066Do</a></li>
</ul>
<p>Neovim viene con un terminal integrado al que puede acceder para
hacer ciertas acciones de forma rápida.</p>
<p>Evidentemente, puede consultar la ayuda oficial:
<code>:h terminal</code>.</p>
<p>El atajo de teclado con el que se pone en modo normal desde el
terminal es <code>&lt;C-\&gt;&lt;C-n&gt;</code>, pero no logro hacerlo
desde una disposición de teclas en español ya que la barra invertida
requiere del uso de una tecla modificadora. En cualquier caso, he optado
por remapearlo a <kbd>Esc</kbd>.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">keymap</span><span class="op">.</span>set<span class="op">(</span><span class="st">&quot;t&quot;</span><span class="op">,</span> <span class="st">&quot;&lt;Esc&gt;&quot;</span><span class="op">,</span> <span class="st">&quot;&lt;C-</span><span class="sc">\\</span><span class="st">&gt;&lt;C-n&gt;&quot;</span><span class="op">)</span></span></code></pre></div>
<p>Advierta que hay que poner dos barras invertidas para poder escapar
dicho sígno.</p>
<p>En Vimscript sería</p>
<pre class="vim"><code>tnoremap &lt;Esc&gt; &lt;C-\&gt;&lt;C-n&gt;</code></pre>
<p>No se necesita escapar la barra invertida.</p>
<p>Desde el modo normal en el terminal, puede hacer las mismas cosas que
cuando edita un archivo. Puede pasar al modo visual, puede copiar
(<em>yank</em>), buscar, etc. Esto hace que sea bastante cómodo
interactuar con la salida del terminal. Con herramientas como Tmux, se
puede hacer esto también, pero yo prefiero que esto venga integrado en
Neovim, por varias razones. Una es que, si edito la salida del terminal
desde Neovim, tengo todos los ajustes que haya hecho a Neovim. Además,
me resulta más cómodo no tener que salir TKTK.</p>
<p>Para volver al modo terminal, se hace como se vuelve al modo insert
desde el modo normal: puede usar <kbd>a</kbd>, <kbd>i</kbd>, etc.</p>
<p>Algo para lo que se puede usar también el terminal integrado de
Neovim es para especificar formas rápidas de lanzar instrucciones de
diverso tipo. A esto es a lo que suelen llamar <em>tareas</em>
(<em>tasks</em>). Así, puede lanzar rápidamente una orden de Make,
etc.</p>
</section>
</section>
<section id="acciones-básicas" class="level1">
<h1>Acciones básicas</h1>
<section id="modo-remplazar" class="level2">
<h2>Modo remplazar</h2>
<p>Además de los modos más usuales, como insertar, normal, etc., existe
el modo remplazar (<em>replace</em>), que es básicamente como el modo
insertar pero, en lugar de desplazar el texto a la derecha del cursor,
lo sobrescribe (<em>overtype</em>). Es muy cómodo para las tablas de los
LMLs, por ejemplo. Se sale del mismo modo que siempre: con
<kbd>Esc</kbd> volverá al modo normal.</p>
<p>Para obtener información oficial, puede consultar, en la ayuda
integrada del editor, la entrada <code>replace-mode</code>
(<code>:help replace-mode</code> o, simplemente
<code>:h replace-mode</code>). Se entra simplemente con la combinación
de teclas <kbd>Shift</kbd> + <kbd>r</kbd>, dentro del modo normal. Verá
que en la esquina inferior izquierda, donde se indica el modo en el que
se encuentra, se muestra <code>-- REPLACE --</code>.</p>
<p>Como curiosidad, en Neovim, como sabrá, el cursor es distinto en modo
normal (cuadradito) que en modo insert (línea vertical). Pues bien, en
modo replace es también distinto: es una línea horizontal bajo el
carácter que va a reemplazar. Así es más cómodo a simple vista saber en
qué modo se encuentra uno.</p>
<p>Para las tablas ahora existe el <a
href="https://neovim.io/doc/user/usr_25.html#25.5">modo
<code>virtualedit</code></a>, que es bastante mejor.</p>
</section>
<section id="recargar-buffer" class="level2">
<h2>Recargar <em>buffer</em></h2>
<p>Se hace con</p>
<pre class="vim"><code>:so %</code></pre>
<p>tal y como explican <a
href="https://superuser.com/questions/132029/how-do-you-reload-your-vimrc-file-without-restarting-vim">aquí</a></p>
<p>No sé por qué pero siempre me da problemas.</p>
</section>
<section id="marcas" class="level2">
<h2>Marcas</h2>
<p>Puede hacer una marca (<em>bookmark</em>) en el archivo que esté
editando, simplemente, en modo normal, pulsando <kbd>m</kbd>
<kbd>k</kbd>, donde <kbd>k</kbd> es un placeholder para una tecla
cualquiera. Podrá hacer tantas como letras tenga en el teclado (creo).
Entonces, la línea en la que se encontraba su cursor se guardará como
una marca asociada a esa letra <kbd>k</kbd>.</p>
<p>Luego, para volver a la línea con la marca <code>k</code>, basta con
que, en modo normal, ponga un acento grave (<em>backtick</em>) seguido
de la letra, es decir, <sub>`</sub>.</p>
</section>
<section id="pliegues" class="level2">
<h2>Pliegues</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=f_f08KnAJOQ"
class="uri">https://www.youtube.com/watch?v=f_f08KnAJOQ</a></li>
</ul>
<p>Los <em>pliegues</em> (<em>folds</em>) son TKTK. Puede obtener
información buscando por <code>fold</code> en la ayuda de Vim:
<code>:help fold</code>.</p>
<p>En principio, se debe usar una marca de pliegue (<em>fold mark</em>):
una de apertura y una de cierre. En principio, la predefinida será</p>
<pre class="vim"><code>&lt;x&gt; {{{</code></pre>
<p>donde <code>&lt;x&gt;</code> es el símbolo o símbolos de apertura de
comentario del lenguaje que se trate. La de cierre es</p>
<pre class="vim"><code>&lt;y&gt; }}}</code></pre>
<p><code>&lt;y&gt;</code> son los símbolos de cierre de comentario.</p>
<p>Se puede cambiar esa marca de <code>{{{</code> y <code>}}}</code> por
la que usted desee. También, se puede hacer que el pliegue sea
automático, por ejemplo, para Python, es muy común hacerlo por
indentación, con</p>
<pre class="vim"><code>set foldmethod=indent</code></pre>
<p>Aun así, el pliegue automático no es algo que me guste, pues prefiero
usarlo para hacer divisiones lógicas del archivo.</p>
<p>Para evitar que los archivos se abran de forma predeterminada con las
partes plegadas, se puede usar</p>
<pre class="vim"><code>set foldlevel=99</code></pre>
<hr />
<p><a href="https://vi.stackexchange.com/a/15440/22600">Aquí</a>
explican lo básico sobre el <em>folding</em> del texto y de la columna
de <em>folding</em>.</p>
<p>Ahora mismo, no soy capaz de que me haga efecto
<code>set foldcolumn=2</code> desde el principio, al incluirlo en el
archivo de configuración de Vim.</p>
<hr />
<p>En cualquier caso, no me gusta lo de especificar pliegues, pues se
usa notación específica para un editor.</p>
</section>
<section id="moverse-por-archivos" class="level2">
<h2>Moverse por archivos</h2>
<p>Aunque ahora con los editores e IDEs modernos mucha gente está
adquiriendo la costumbre de separar menos en archivos distintos el
código, creo que esta es una mala costumbre; un estilo equivocado de
construir un proyecto de <em>software</em>.</p>
<p><a
href="https://www.youtube.com/watch?v=faoPxXSj8n0&amp;t=11s">Tutorial</a>.</p>
<p>Aunque puede ejecutar comandos de su <em>shell</em> desde Ex, dentro
de Vim o Neovim, cosa que se hace anteponiendo un signo de cierre de
exclamación (<code>!</code>) al comando de <em>shell</em>, por
ejemplo,</p>
<pre class="vim"><code>:!grep &lt;busqueda&gt; &lt;ruta&gt;</code></pre>
<p>en realidad no le encuentro gran utilidad. Prefiero salirme
momentáneamente al <em>shell</em>, cosa que se hace con la combinación
de teclas <kbd>Ctrl</kbd> + <kbd>z</kbd>, y ejecutar los comandos desde
el editor en el propio editor de línea del <em>shell</em>, pues así
puedo usar el autocompletado, etc. Para volver a Neovim, se usa el
comando <code>fg</code>. También, tanto Vim como Neovim cuentan ahora
con un terminal integrado, pero no le veo ventaja con lo que acabo de
explicar.</p>
<p>Por cierto, sobre la cuestión de qué es mejor, si usar el ejecutable
de Neovim para moverse o comandos dentro del propio Neovim, esto depende
de lo que prefiera. Aunque a mucha gente no le guste hacerlo con el
ejecutable, no está tan mal. Además, se adhiere más a la filosofía de
Unix. Pero, si lo que desea es hacerlo todo al estilo Unix, mejor que
usar Neovim sería que usase un editor más minimalista, como Nano, y
tratar de hacer todo lo posible desde el <em>shell</em>.</p>
<p>Aunque existen <em>plug-ins</em> para mostrar la parte relevante del
sistema de archivos y moverse por esta, como Nerdtree o, mejor,
Telescope, o incluso Netrw, un <em>plug-in</em> para una gestión de
archivos muy simple que viene preinstalado en Vim y Neovim, tampoco hago
mucho uso de estos, sino que prefiero usar las funcionalidades que
vienen de serie con el propio Neovim (que heredó de Vim). Neovim cuenta
con ciertos comandos como los del <em>shell</em>, pero que no son los
mismos en realidad: <code>:find</code>, <a
href="#vimgrep"><code>:vimgrep</code></a>, etc. Al usar
<code>:grep</code> o <code>:vimgrep</code> (de Vim), podrá moverse por
los resultados del comando en la lista <em>quickfix</em> (<em>quickfix
list</em>) de Neovim.</p>
<p>Por cierto, al parecer se puede hacer que, en lugar de la herramienta
<code>grep</code> del <em>shell</em>, <a
href="https://www.reddit.com/r/neovim/comments/1c0bemk/using_ripgrep_as_grepprg_to_search_in_the_current/">se
use, si lo prefiere RipGrep</a>, que es una alternativa moderna a
<code>grep</code>, aunque en realidad se trata de herramientas con
propósitos ligeramente diferentes.</p>
<p>Existe un <em>plug-in</em>, que viene integrado de serie en Vim y
Neovim, llamado Netrw, que es una interfaz TUI de gestión de archivos,
dentro del propio editor. Aunque antes lo usaba, ahora mi preferencia es
deshabilitarlo para que no me entorpezca. Para gestionar archivos,
prefiero <q>salir</q> al <em>shell</em>. Además, al tener abierto un
<em>buffer</em> de Netrw, entorpecía en parte mi uso del editor.</p>
<section id="buffers-y-lista-de-argumentos" class="level3">
<h3><em>Buffers</em> y lista de argumentos</h3>
<p>Antes de hablar de los comandos que puede usar para moverse, debe
saber que Neovim cuenta con una <em>lista de argumentos</em>
(<em>arguments list</em> o <em>arglist</em>), que sería como una lista
con los archivos y carpetas que se le han pasado al comando de ejecución
de Neovim (normalmente, <code>nvim</code>) al invocarlo, aunque también
se puede manipular esta desde dentro del propio Neovim.</p>
<p>Tal y como hemos dicho, se puede abrir Neovim especificando como
argumentos del comando de ejecucón de Neovim los archivos o carpetas que
desea abrir. Los archivos aparecerán abiertos en <em>buffers</em> y en
la lista de argumentos. Las carpetas seleccionadas, cuando se mueve a su
<em>buffer</em> asociado, verá que lo que hace es mostrarla en el editor
Netrw. Como pasa normalmente con este tipo de herramientas muy asociadas
al <em>shell</em>, en este caso se pueden usar comodines
(<em>wildcards</em>) para hacer más cómoda la selección de
argumentos.</p>
</section>
<section id="comando-args" class="level3">
<h3>Comando <code>:args</code></h3>
<p>Una forma muy práctica y que uso mucho es con los comandos de la
lista de argumentos, que suelen comenzar por <code>:arg</code>. Se
tiene, por ejemplo, <code>:args</code>, que, si se introduce sin darle
ningún argumento, mostrará la lista de argumentos que tiene en ese
momento. Si al comando <code>:args</code> se le añaden algún o algunos
argumentos, que deben ser rutas (absolutas o relativas) de archivos o
carpetas, lo que hará será vaciar la lista de argumentos y llenarla con
los argumentos que le ha dado. También, abrirá todas esas rutas como
<em>buffers</em>. Esto mismo se puede hacer también con el comando
<code>:next</code>, siempre y cuando añada a este algún argumento. La
forma abreviada de <code>:next</code> es <code>:n</code>. Se tiene
también el comando <code>:argadd</code>, que permite añadir elementos a
la lista de argumentos sin vaciarla previamente.</p>
<p>Para <q>sacar</q> elementos de la lista de argumentos, se usa
<code>:argdelete</code> o, de forma abreviada <code>:argdel</code>.
Admite el uso de comodines. Así, por ejemplo, si desea vaciar dicha
lista, podría lograrlo con <code>:argdelete *</code>.</p>
<p>Se encontrará con un <em>buffer</em> en el que tiene abierto un
elemento de la lista de argumentos, es decir, un archivo o carpeta. Si
introduce el comando <code>:next</code> sin argumentos, pasará a un
<em>buffer</em> con el siguiente elemento en la lista de argumentos.
Para atrás, sería con <code>:previous</code>. Personalmente, no me gusta
usar estos comandos, pues me resultan incómodos. Prefiero usar
<code>:bnext</code> y <code>:bprevious</code> o, más bien, sus formas
abreviadas <code>:bn</code> y <code>:bp</code>, para moverme entre
<em>buffers</em>. Creo que en realidad hacen lo mismo. TKTK.</p>
</section>
<section id="comando-edit" class="level3">
<h3>Comando <code>:edit</code></h3>
<p>Tambén, desde el propio Neovim, existe el comando <code>:edit</code>,
o, simplemente, <code>:e</code>, en su forma corta. Como argumento, se
deberá poner un archivo o una carpeta, al igual que con el comando del
ejecutable de Neovim, solo que deberá seleccionar un único archivo, pues
<a
href="https://jdhao.github.io/2020/10/28/edit_multiple_files_nvim/">no
deja seleccionar varios</a>. Para abrir varios de golpe, deberá usar
otros comandos que se ven aquí mismo, como <code>:args</code> o
<code>:find</code>. Si el argumento es un archivo, lo abrirá en un
<em>buffer</em>; si se trata de una carpeta, la mostrará en Netrw.
Aunque no los incluirá en la lista de argumentos. Además, al igual que
sucede con <code>:find</code>, con <code>:edit</code> se añadirán esos
archivos o carpetas a los <em>buffers</em> que tiene; no reemplazará a
los que ya tiene.</p>
<p>Personalmente, cuando uso Vim o Neovim, me encuentro constantemente
haciendo uso del comando <code>:e</code>, pues es muy cómodo para
moverse.</p>
<p>Un truco que uso con <code>:e</code> es usar su autocompletado al
máximo. Como quizás ya sepa, <code>:e</code> cuenta con autocompletado
(<em>tab completion</em>). Esto autocompleta con los archivos o carpetas
en los directorios de las carpetas que estén incluidas en la variable
<code>path</code> del editor. Mientras le hace el autocompletado, puede
distinguir los archivos de las carpetas porque estas últimas aparecen
con una barra inclinada (<code>/</code>) al final del nombre. Para
entrar, dentro de una carpeta que me vaya mostrando, y seguir
seleccionando dentro de esta, lo que se puede hacer es pulsar una vez la
tecla <kbd>Shift</kbd> y seguir pulsando <kbd>Tab</kbd> para que muestre
archivos y carpetas dentro de esta. Es algo que me resulta
comodísimo.</p>
<p>Existen otras formas, pero son más incordio. Por ejemplo, usar el
comodín asterisco, <code>*</code>, y seguir pulsando <kbd>Tab</kbd> o
usar la barra inclinada, <kbd>/</kbd>, y seguir con <kbd>Tab</kbd>.</p>
</section>
<section id="comando-find" class="level3">
<h3>Comando <code>:find</code></h3>
<p>Otro comando en Neovim que viene muy bien para moverse es
<code>:find</code>. Este debe usarlo siempre con uno o varios
argumentos, que, al igual que con los otros comandos, deben ser rutas
absolutas o relativas de archivos o carpetas. También se pueden emplear
comodines. Con el comando <code>:find</code>, las rutas que introduzca
como argumentos se añadirán como <em>buffers</em>, pero no a la lista de
argumentos.</p>
<p>Al igual que sucede con <code>:edit</code>, con <code>:find</code> se
añadirán esos archivos o carpetas a los <em>buffers</em> que tiene; no
remplazará a los que ya tiene.</p>
</section>
<section id="comando-filter" class="level3">
<h3>Comando <code>:filter</code></h3>
<p>El comando <code>:filter</code> puede usarse para ir, dentro de una
carpeta con muchos archivos, a la última que se editó. Se puede hacer
con</p>
<pre class="vim"><code>:filter &#39;*.md&#39; oldfiles</code></pre>
<p>si, por ejemplo, desea filtrar por archivos con extensión
<em>.md</em>, aunque no entiendo por qué parece que está mal. Por
cierto, se tienen que usar comillas simples forzosamente.</p>
<p>El comando <code>:filter</code> en realidad, tal y como indica su
nombre, lo que hace es filtrar. Aquí, el comando que se está filtrando
es <code>:oldfiles</code>.</p>
<p>En este ejemplo, si lo prefiere, puede no especificar el tipo de
archivo. Sería así:</p>
<pre class="vim"><code>:filter &#39;&#39; oldfiles</code></pre>
<p>que es más cómodo.</p>
<p>Desde la API de Lua, se puede acceder a la tabla
<code>oldfiles</code>, que está en <code>vim.v.oldfiles</code>.
TKTK.</p>
<p>Esto sería algo que creo que estaría bien asociarla a una secuencia
de teclas con la <em>leader key</em>, aunque en principio tampoco es
algo que haga tan a menudo.</p>
<p>En Neovim se tiene de serie activada la funcionalidad de
autocompletado (<em>tab completion</em>) para los argumentos de algún
comando que acepte como argumentos nombres de archivos o carpetas. Es
decir, si introduce uno de estos comandos, deja un espacio y luego pulsa
<kbd>Tab</kbd>, se le mostrarán las opciones que tiene, es decir,
aparecerán los archivos y carpetas que puede abrir. Los diferenciará en
que los nombres de las carpetas terminan aquí con una barra
(<code>/</code>).</p>
<p>Otra cosa que sería interesante que supiese es que puede indicar a
Neovim que realice una acción sobre varios archivos; no solo uno. Con el
comando <code>:argdo</code>, seguido de la acción a realizar, se
realizará dicha acción sobre todos los archivos que se encuentran en ese
momento en la lista de argumentos. Por ejemplo, puede realizar una
búsqueda o una sustitución sobre varios archivos con un solo
comando.</p>
<p>Otra cosa que debe saber es que, al especificar una ruta, ya sea
absoluta o relativa, como argumento de algún comando, puede usar un
símbolo para indicar que se busque de forma recursiva, es decir, con
cualquier grado de anidación. Ese símbolo del que hablo son dos
asteriscos seguidos: <code>**</code>. Por ejemplo,</p>
<pre class="vim"><code>:find fuentes/**/*.md</code></pre>
<p>abriría todos los archivos que, estando bajo la carpeta
<em>fuentes</em>, con cualquier grado de anidación, tengan por extensión
<em>.md</em>. Con lo de <q>con cualquier grado de anidación</q> quiero
decir que basta con que esté en el árbol de carpetas bajo el directorio
<em>fuentes</em>, aunque no sea un descendiente directo de este.</p>
<p>Es muy común añadir <code>**</code> a la variable de Neovim
<code>:path</code>, para que estos comandos sean más cómodos de usar. No
sé si se usa solo para el comando <code>:find</code> o si sirve también
para los otros. Personalmente, sí uso esto en mi configuración, pues me
resulta muy cómodo buscar rápidamente. Esto se configura de la forma
siguiente:</p>
<pre class="vim"><code>:set path+=**</code></pre>
<p>En Lua,</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">path</span> <span class="op">=</span> <span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">path</span> <span class="op">+</span> <span class="st">&quot;**&quot;</span></span></code></pre></div>
<p>(tanto en su designación normal como si lo hace terminando con barra,
<code>/</code>)</p>
<p>Vea la <a href="#buffer-ventana-pestana">diferencia entre
<em>buffer</em>, ventana y pestaña</a>.</p>
<p>Otra cos muy útil es saltar a archivo bajo el cursor. Se hace con
<kbd>g</kbd> <kbd>f</kbd>. Esto está muy bien cuando se está en un
índice de contenidos o algo así.</p>
</section>
</section>
<section id="buscar" class="level2">
<h2>Buscar</h2>
<p>Puede consultar la documentación oficial con <code>:h /</code>.</p>
<p>En cuanto a buscar, encontré una <a
href="https://www.youtube.com/watch?v=kgS2cpGfSio">forma de hacerlo muy
cómoda</a>.</p>
<p>Es importante usar <code>c</code> para que pida confirmación,
<code>g</code> para que lo haga de forma global, es decir, no solo en la
primera instancia. También, si deseamos que busque solo la palabra que
decimos, y no cuando sea parte de una palabra, se encierre entre
<code>\&lt;</code> y <code>\&gt;</code>.</p>
<p>De todos modos, ahora con LSP, ya no es necesario buscar con tanta
frecuencia.</p>
<p>Si desea buscar o remplazar sobre varios archivos, se debe hacer de
un modo algo diferente. Debe hacer uso de lo que se conoce como la <a
href="https://neovim.io/doc/user/editing.html#argument-list">lista de
argumentos</a> (<em>argument list</em>).</p>
<p>La lista de argumentos se creó básicamente para realizar acciones
sobre varios archivos simultaneamente. No solo permite buscar y
remplazar, sino que es mucho más versátil de lo que son, en este
sentido, la mayoría de editores e IDEs.</p>
<p>No confunda la lista de argumentos con los <em>buffers</em>. Todo
archivo de la lista de argumentos estará también presente en la lsta de
<em>bufers</em>, a menos que los haya eliminado de esta, por ejemplo,
con <code>:bdel</code> o <code>:bwipe</code>. Pero es común que las
entradas en la lista de <em>buffers</em> no estén presentes en la de
argumentos.</p>
</section>
<section id="movimientos-básicos" class="level2">
<h2>Movimientos básicos</h2>
<p>Los movimientos básicos suele ser lo primero que se explica en los
manuales de Vim. Eso, y cómo salir del editor. (Siempre se hacen bromas
con esto último.)</p>
<p>El modo más fácil de aprenderlos creo que es usando Vimtutor o
mediante alguna chuleta (<em>cheatsheet</em>) de las muchas que hay por
la web.</p>
<p>Hay ciertos movimientos básicos que se pueden hacer con teclas más
fáciles de acceder, como moverse una columna de texto hacia la derecha,
que como sabrá se hace con <kbd>l</kbd>. Puede hacerse también con
<kbd>Espacio</kbd>, que es mucho más cómodo. Para ir una columna hacia
la izquierda, en lugar de <kbd>h</kbd>, puede usar la tecla de borrar
(<em>backspace</em>). Para bajar, en lugar de <kbd>j</kbd>,
<kbd>Intro</kbd>; bueno, no son exactamente iguales. Lo que quiero decir
es que hacer un uso eficiente de Vim no se limita, ni mucho menos, a
saber moverse con <kbd>h</kbd>, <kbd>j</kbd>, <kbd>k</kbd> y
<kbd>l</kbd>. De hecho, eso es lo menos interesante.</p>
<p>Si desea ir al final de un párrafo <em>hard-wrapped</em>, para mí, lo
más cómodo es moverme al renglón posterior al párrafo, con <kbd>}</kbd>,
y luego moverme hacia atrás con <kbd>borrado</kbd>. La otra forma, para
mí más incómoda, es moverse hasta el último de los renglones del párrafo
(puede hacerlo cómodamente dejando pulsada la tecla <kbd>Intro</kbd><a
href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a>) y, cuando se encuentre en este, ir
al final del renglón, con <kbd>$</kbd>.</p>
<p>Hay mucha gente que usa otra forma de editar. Si la usan es la
consideran más cómoda, aunque a mí no me lo parece. Me refiero al uso de
la numeración relativa. Esta le permite hacer operaciones sobre cierto
número de renglones de un solo golpe, sin necesidad de seleccionar y
aproximarse. Veámoslo con un ejemplo con el código siguiente:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>polkit<span class="op">.</span><span class="fu">addRule</span>(<span class="kw">function</span>(action<span class="op">,</span> subject) {</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> ((action<span class="op">.</span><span class="at">id</span> <span class="op">==</span> <span class="st">&quot;org.freedesktop.login1.reboot&quot;</span> <span class="op">||</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    action<span class="op">.</span><span class="at">id</span> <span class="op">==</span> <span class="st">&quot;org.freedesktop.login1.reboot-multiple-sessions&quot;</span> <span class="op">||</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    action<span class="op">.</span><span class="at">id</span> <span class="op">==</span> <span class="st">&quot;org.freedesktop.login1.power-off&quot;</span> <span class="op">||</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    action<span class="op">.</span><span class="at">id</span> <span class="op">==</span> <span class="st">&quot;org.freedesktop.login1.power-off-multiple-sessions&quot;</span> <span class="op">||</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    action<span class="op">.</span><span class="at">id</span> <span class="op">==</span> <span class="st">&quot;org.freedesktop.login1.suspend&quot;</span> <span class="op">||</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    action<span class="op">.</span><span class="at">id</span> <span class="op">==</span> <span class="st">&quot;org.freedesktop.login1.suspend-multiple-sessions&quot;</span> <span class="op">||</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    action<span class="op">.</span><span class="at">id</span> <span class="op">==</span> <span class="st">&quot;org.freedesktop.login1.hibernate&quot;</span> <span class="op">||</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    action<span class="op">.</span><span class="at">id</span> <span class="op">==</span> <span class="st">&quot;org.freedesktop.login1.hibernate-multiple-sessions&quot;</span>) <span class="op">&amp;&amp;</span> subject<span class="op">.</span><span class="fu">isInGroup</span>(<span class="st">&quot;power&quot;</span>))</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> polkit<span class="op">.</span><span class="at">Result</span><span class="op">.</span><span class="at">YES</span><span class="op">;</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Imagine que se encuentra en la línea 2 y desea eliminar todo lo que
hay hasta la 9, incluyéndola. Sería muy sencillo de hacer si tiene la
numeración relativa, pues verá que la última se encuentra en el renglón
7 respecto al que se encuentra su cursor: <kbd>d</kbd> <kbd>7</kbd>
<kbd>j</kbd>. Se lo indica de forma directa.</p>
<p>Esto quizás ya no sea tan conveniente. Ahora, con la integración con
Tree-Sitter, uno puede manipular de forma muy directa ciertos objetos de
textos, como, por ejemplo, el cuerpo en la definición de una clase o de
una función. Esto se puede configurar con el <em>plug-in</em>
<code>tree-sitter-objects</code>.</p>
<p>Aunque esta es la forma más rápida que conozco de llevar a cabo esa
edición, no me gusta tanto, pues tengo que fijarme en la línea, buscar
su número (7 en este caso) y, además, usar una tecla de número, que
tienen un acceso más complicado en el teclado. En mi opinión, merece más
la pena usar la selección y moverme.</p>
<p>Al no usar numeración relativa y esta forma tan rápida de moverse, me
veo obligado a usar la selección para ciertas operaciones y, por tanto,
realizo más movimientos. La ventaja creo que está en que no pierdo nada
de tiempo buscando la línea a la que me quiero mover y, además, las
teclas de números me parecen algo incómodas y trato de evitar su uso. De
mi modo, hago más movimientos pero son más mecánicos; los hago sin
pensar.</p>
<p>En el mismo ejemplo, lo primero sería entrar en el modo visual, pero
para toda la línea, con <kbd>Shift</kbd> <kbd>v</kbd>. Luego, dejar
pulsada <kbd>Intro</kbd> hasta que llegue seleccionando hasta la línea
que deseo. Así se habrá seleccionado todo lo que deseo eliminar.
Entonces, no queda más que pulsar <kbd>d</kbd> para eliminar lo
seleccionado.</p>
<p>Otra forma de moverse rápido es mediante la búsqueda, tal y como
explican al comienzo de <a
href="https://www.youtube.com/watch?v=kgS2cpGfSio">este vídeo</a>.</p>
</section>
</section>
<section id="acciones-intermedias" class="level1">
<h1>Acciones intermedias</h1>
<section id="autocompletado" class="level2">
<h2>Autocompletado</h2>
<section id="omnicompletion" class="level3">
<h3>Omnicompletion</h3>
<p>Refs.:</p>
<ul>
<li><a href="https://vim.fandom.com/wiki/Omni_completion"
class="uri">https://vim.fandom.com/wiki/Omni_completion</a></li>
</ul>
<p>La forma tradicional del autocompletado en Vim es con lo que se
conoce como Omnicompletion, que viene de serie en Vim y Neovim, aunque
hay que activarlo, pues de forma predeterminada viene desactivado. Más
información, con <code>:h compl-omni</code>. Para activarlo, puede hacer
lo siguiente:</p>
<pre class="vim"><code>filetype plugin on
set omnifunc=syntaxcomplete#Complete</code></pre>
<p>Creo que la primera línea en realidad no es necesaria, pues en Neovim
viene activada de forma predeterminada.</p>
<p>Omnicompletion tiene autocompletados para varios lenguajes, como SQL,
HTML, CSS, JavaScript y PHP, pero hay muchos para los que no lo tiene,
por lo que deberá crear sus propios <em>scripts</em> de omnicompletion o
buscar alguno hecho por alguien. TKTK. También, este autocompletado
puede hacer uso de las <em>tags</em>, con lo que tendrá un
autocompletado que tendrá en cuenta otros archivos distintos al que está
editando pero del mismo proyecto. La información sobre las distintas
funciones de autocompletado para los distintos lenguajes puede
consultarla, en la ayuda oficial, en la entrada
<code>compl-omni-filetypes</code>.</p>
<p>Una vez que lo tenga configurado, para hacer uso de Omnicompletion,
debe usar, en modo insert, la combinación de teclas <kbd>Ctrl</kbd> +
<kbd>x</kbd> <kbd>Ctrl</kbd> + <kbd>o</kbd>. En cualquier caso, el
autocompletado de palabras que aparecen en el mismo archivo que está
editando creo que lo tiene siempre y se accede con <kbd>Ctrl</kbd> +
<kbd>n</kbd> o <kbd>Ctrl</kbd> + <kbd>p</kbd> en modo insert. En ambos
casos se irá en sentido opuesto. Además, <kbd>Down</kbd> (la flecha
abajo) y <kbd>Up</kbd> (arriba), en modo insert, tendrían el mismo
efecto que ambos ajustes de teclado, respectivamente.</p>
<p>Existen formas más modernas de configurar el autocompletado en
Neovim. Estas formas modernas suelen hacer uso de LSP, lo cual da más
posibilidades que Omnicompletion.</p>
</section>
<section id="con-lsp" class="level3">
<h3>Con LSP</h3>
<p>Hasta hace relativamente poco, el autocompletado de LSP debía
realizarse con algún <em>plug-in</em>. El más popular era <a
href="https://github.com/hrsh7th/nvim-cmp"
class="paq"><code>nvim-cmp</code></a>. A partir de la versión 0.10,
Neovim cuenta de serie con autocompletado. La parte del código se
implementa con el <a
href="https://github.com/neovim/neovim/pull/27339"><em>pull request</em>
(PR) 27339</a>.</p>
<p>En esta funcionalidad, también se puede usar para los retazos
(<em>snippets</em>), aunque personalmente no los uso.</p>
<p><a
href="https://neovim.io/doc/user/insert.html#ins-completion"><em>insert
mode completion</em></a></p>
</section>
</section>
<section id="corrección-lingüística" class="level2">
<h2>Corrección lingüística</h2>
<p>Antes de nada, me gustaría aclarar que la corrección lingüística no
es algo importante a la hora de programar. Personalmente, no la uso.
Cuando sí la uso en Neovim es cuando estoy editando algún archivo de
algún lenguaje de documentación, como, por ejemplo, Markdown, Djot o
LaTeX.</p>
<p>Como sabrá, la corrección lingüística consta a su vez de corrección
ortográfica (<em>spell checking</em>) y corrección gramatical
(<em>grammar checking</em>). Aquí, trataremos únicamente la primera, que
es la única que suelen integrar los editores de código y los IDEs.</p>
<p>Tal y como he explicado, para el desarrollo esto no es algo que se
use muy a menudo. Casi no se le da importancia. Un desarrollador la
usaría para la documentación técnica, como, por ejemplo, un archivo
<em>README.md</em> (de Markdown) de un repositorio de Git, para un
mensaje de <em>commit</em> de Git, para un <em>docstring</em> de Python,
etc. También, quizás, para los comentarios del código, aunque tampoco es
imprescindible, pues es poca la prosa que se escribe en el código, a
menos que haga <em>literate programming</em>, que no suele ser
habitual.</p>
<p>Lo primero que debe saber es que se tienen, por un lado, las listas
de palabras (<em>word lists</em>) y, por otro, los diccionarios
(<em>dictionaries</em>). Junto con los diccionarios, suele haber también
listas de afijos (<em>affixes</em>).</p>
<p>La mayoría de sistemas tipo Unix traen, de forma predeterminada, en
algún lugar de su sistema de archivos, una lista de palabras del idioma
inglés. En macOS, por ejemplo, su ruta es el archivo <em>words</em>
dentro de la carpeta <em>/usr/share/dict</em>.</p>
<p>Esta lista de palabras puede usarla para hacer pruebas y cosas así,
pero no es en realidad en lo que se basa normalmente el
<em>software</em> (el que sea) para hacer la corrección ortográfica.</p>
<p>En lo que respecta a Vim y Neovim, actualmente hacen uso de la
biblioteca ortográfica (<em>spelling library</em>) <a
href="https://github.com/GNUAspell/aspell">Aspell</a>. Este tipo de
bibliotecas cuentan también con diccionarios y listas de afijos, para
los distintos idiomas que soporta. Existen alternativas a Aspell algo
más modernas, como, por ejemplo, Hunspell, que de hecho los
desarrolladores de Neovim <a
href="https://github.com/neovim/neovim/issues/12064">están tratando</a>
de hacer que esta sea la biblioteca ortográfica que use.</p>
<p>En otros editores e IDEs se están usando otros también modernos, como
<a href="https://github.com/streetsidesoftware/cspell">Cspell</a>, que
se puede usar en VSCode, mediante una extensión.</p>
<p>Todas estas bibliotecas ortográficas tienen también la posibilidad de
ser usadas mediante una herramienta de línea de comandos. Lo único es
que, en ese caso, se pierde la interacción a este respecto.</p>
<p>Dicho esto, voy a explicar aquí cómo se usa el corrector ortográfico
integrado de Neovim, que es el mismo que el de Vim, pues es lo que
tenemos actualmente. Creo que lo llaman Vimspell.</p>
<p>Hay varias opciones a configurar en los ajustes. Una es</p>
<pre class="vim"><code>setlocal spell</code></pre>
<p>Recuerde la diferencia entre <code>set</code> y
<code>setlocal</code>. Este último tiene efecto solamente en el
<em>buffer</em> o ventana desde la que se lanza dicho comando, mientras
que el primero hará que se aplique de forma global ese ajuste, en ese
proceso del editor. Normalmente, tengo deshabilitada la corrección
ortográfica y, en ciertos momentos, la activo en un <em>buffer</em>,
para hacer comprobaciones. Así es como me gusta trabajar.</p>
<p>Ahora, hay que cargar los diccionarios:</p>
<pre class="vim"><code>setlocal spelllang+=es_es</code></pre>
<p>De forma predeterminada, viene <code>en</code>, que es el del idioma
inglés. Los otros tendrá que añadirlos con el comando anterior. Así,
carga el diccionario del español de España.</p>
<p>También, me gusta usar el diccionario <code>kspell</code>:</p>
<pre class="vim"><code>complete+=kspell</code></pre>
<p>o, si lo prefiere haciendo la configuración en Lua,</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">complete</span> <span class="op">=</span> <span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">complete</span> <span class="op">+</span> <span class="st">&quot;kspell&quot;</span></span></code></pre></div>
<p>Así, se ha añadido la cadena <code>kspell</code> a la variable
<code>complete</code>, quedando ahora con el valor
<code>.,w,b,u,t,kspell</code>. La información sobre dicha variable puede
consultarla buscando por <code>'complete'</code> en la ayuda oficial.
Como quizás ya sepa, puede consultar el valor asignado en ese momento a
esa variable con</p>
<pre class="vim"><code>:echo &amp;complete</code></pre>
<p>Como digo, esto lo pongo solo para prosa; no para código. Por tanto,
estas configuraciones van en algún <code>autocmd</code>, como explican
<a href="https://thoughtbot.com/blog/vim-spell-checking">aquí</a>.</p>
<p>Quizás, se debería asignar un archivo <em>spellfile</em> TKTK.</p>
<p>Las secuencias de teclas que más uso, cuando estoy realizando la
corrección ortográfica, son las siguientes:</p>
<ul>
<li><code>]s</code> — Salta a la palabra siguiente que considera
errónea.</li>
<li><code>[s</code> — Salta a la palabra anterior que considera
errónea.</li>
<li><code>zg</code> — Añade la palabra bajo el cursor al diccionario que
está seleccionado en ese <em>buffer</em> o ventana.</li>
<li><code>zw</code> — Elimina la palabra bajo el cursor del diccionario
que está seleccionado en ese <em>buffer</em> o ventana.</li>
<li><code>zG</code> — Como <code>zg</code> pero añade la palabra en la
lista de palabras interna (<em>internal wordlist</em>; vea
<code>:help internal-wordlist</code>). La lista de palabras interna se
usa para todos los <em>buffers</em> donde está habilitado
<em>spell</em>. Es temporal; no se almacena. Se limpia al salir del
editor, por lo que, al salir y volver a entrar en este, volverán a estar
marcados como errores ortográficos.</li>
<li><code>z=</code> — Muestra sugerencias de corrección para una palabra
errónea. No lo suelo usar.</li>
</ul>
<p>Lo cierto es que tampoco es algo que use con gran frecuencia y además
se pueden manipular editando los archivos, por lo que lo normal es que
no recuerde las anteriores secuencias de Neovim.</p>
<p>¿Cómo se haría para añadir una lista de palabras? Se puede crear uno
una lista de palabras específica para una temática concreta. Por
ejemplo, para ciencias de la computación. Crearíamos, en la carpeta en
la que tenemos los archivos con extensión <em>.add</em>, que en mi caso
sería en <em>~/.config/nvim/spell</em>, el archivo
<em>comp-sci.utf-8.add</em> (no puede tener guión bajo en el nombre; no
sé si es obligatorio poner como infijo en el nombre la codificación del
archivo: utf-8, ascii, etc.). En este, metemos algunas palabras para que
reconozca; por ejemplo,</p>
<pre><code>Git
GitHub
LaTeX
TeX
SVC
Vim
Neovim</code></pre>
<p>Es conveniente disponer las líneas en orden alfabético y eliminar las
repetidas. Esto se puede hacer muy fácilmente seleccionando todo en modo
visual y, después, aplicándole un comando de <em>shell</em>, como se
muestra a continuación:</p>
<pre class="vim"><code>:! sort | uniq</code></pre>
<p>o, si lo prefiere, hacerlo directamente desde el <em>shell</em>, sin
necesidad de hacerlo desde Neovim.</p>
<p>Luego, añadiríamos la ruta del archivo al parámetro
<em>spellfile</em> en el archivo de configuración de Vim:</p>
<pre class="vim"><code>set spellfile+=$HOME/.config/nvim/spell/espanol.utf-8.add
set spellfile+=$HOME/.config/nvim/spell/ingles.utf-8.add
set spellfile+=$HOME/.config/nvim/spell/compsci.utf-8.add</code></pre>
<p>o, si prefiere en Lua,</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">spellfile</span> <span class="op">=</span> <span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">spellfile</span> <span class="op">+</span> <span class="st">&quot;$HOME/.config/nvim/spell/espanol.utf-8.add&quot;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">spellfile</span> <span class="op">=</span> <span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">spellfile</span> <span class="op">+</span> <span class="st">&quot;$HOME/.config/nvim/spell/ingles.utf-8.add&quot;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">spellfile</span> <span class="op">=</span> <span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">spellfile</span> <span class="op">+</span> <span class="st">&quot;$HOME/.config/nvim/spell/compsci.utf-8.add&quot;</span></span></code></pre></div>
<p>Debe crear esos archivos realmente. Ojo, no los confunda con
<em>es_es.utf-8.add</em> y <em>en_us.utf-8.add</em>, que estarán en la
<em>runtime path</em> y el usuario no debería tocarlos.</p>
<p>También, debe crear el archivo con extensión <em>.spl</em>, a partir
del <em>.add</em>. Dentro de Vim, hacemos:</p>
<pre class="vim"><code>:mkspell! ~/.config/nvim/spell/compsci.utf-8.add</code></pre>
<p>Y, finalmente, lo cargaríamos con los demás <em>spelllangs</em>, por
ejemplo, haciendo uso de un autocomando para que se carguen de forma
automática para los archivos Markdown:</p>
<pre class="vim"><code>autocmd FileType markdown setlocal spell spelllang=es_es,espanol,en,ingles,compsci</code></pre>
<p>Así, habrá creado el archivo <em>compsci.utf-8.spl</em>. Debe
advertir que <em>es_es</em> y <em>en_us</em> son especiales y se los
descarga Neovim. No están en la misma ruta que los que haya creado
usted.</p>
<p>Me da un error. El problema está en que el comando
<code>mkspell</code> crea los archivos nombrándolos con un <em>.add</em>
entre medias. Es decir, algo así, <em>compsci.utf-8.add.spl</em>. La
forma en la que lo soluciono es eliminarle manualmente eso de
<em>.add</em> a todos.</p>
<p>Tras esto, en este ejemplo, al abrir un archivo de Markdown, ya no
nos mostrará como error esas palabras: LaTeX, etc.</p>
<p>Cuando tiene cargadas varias listas de palabras de corrección
ortográfica y gramatical (recuerde, se cargan en
<code>spelllang</code>), para añadir una palabra a una en concreto, debe
anteponer el número de la lista antes de la secuencia <code>zg</code>.
Será el número del orden en el parámetro <em>spellfile</em>, comenzando
a contar desde 1, pero, ojo, saltándose los predefinidos como, por
ejemplo, <code>es_es</code> y <code>en_us</code>. Por ejemplo, para
añadir una palabra, en este ejemplo, al diccionario comp-sci, se pondría
encima de la palabra que desea añadir y luego pulsaría <code>3zg</code>,
si su diccionario de ciencias de la computación está en tercer lugar al
excluir los que dijimos. Al hacer esto, en principio, debería
desaparecer. Creo que no hace falta convertirlo al archivo
<em>.spl</em>. Aun así, creo que sería recomendable convertirlo para
tener actualizado dicho archivo.</p>
<pre class="vim"><code>:mkspell! ~/.config/nvim/spell/comp-sci.utf-8.add</code></pre>
<p>No se por qué pero no me deja de detectar como error las palabras
añadidas al diccionario de español personal. Sí las detecta si los añado
al inglés. TKTK.</p>
<p>Estaría bien hacer que, de forma automática, tras modificar algún
archivo <em>.add</em>, Neovim hiciese por sí mismo eso del
<code>mkspell!</code>. Sería fácil de hacer con la herramienta de Unix
<code>entr</code>. O, quizás mejor, con una función de Vim que se
ejecute automáticamente bajo ciertas condiciones.</p>
</section>
<section id="actuar-sobre-varios-archivos" class="level2">
<h2>Actuar sobre varios archivos</h2>
<p>Esto lo explican en <a
href="https://neovim.io/doc/user/usr_26.html#26.3">la entrada
correspondiente</a> en la ayuda oficial de Neovim. También, puede
consultar <a href="https://vi.stackexchange.com/a/2777/22600">este
tutorial</a>.</p>
<p>En principio, existen comandos de Ex para poder realizar operaciones
sobre varios archivos simultáneamente: <code>bufdo</code>, para
<em>buffers</em>, <code>tabdo</code>, para pestañas (<em>tabs</em>) y
<code>windo</code>, para ventanas. No obstante, Vim y Neovim cuentan
también con una lista de argumentos (<em>arguments list</em>)
precisamente para operar sobre varios archivos simultáneamente sin
modificar lo que tenemos abiertos en ese momento. Al igual que los
comandos que acabamos de exponer, actuar sobre los archivos en la lista
de argumentos se hace con <code>argdo</code>. Puede consultar la lista
de argumentos en la ayuda integrada del editor, en la entrada
<code>argument-list</code> (<code>:h argument-list</code>).</p>
<p>¿Pero cómo se añaden archivos a la lista de argumentos? En principio,
si abrimos Vim o Neovim con archivos como argumento, estos estarán,
además de abiertos como <em>buffers</em>, en la lista de argumentos. La
lista de argumentos hace referencia a los argumentos que se le han
pasado al ejecutable de Vim o Neovim.</p>
<p>Por ejemplo, se pueden añadir cuando vaya a abrir Neovim:</p>
<pre><code>$ nvim archivo1.md archivo2.md</code></pre>
<p>Una vez abierto, para consultar los archivos que tiene en la lista de
argumentos basta con</p>
<pre class="vim"><code>:args</code></pre>
<p>En este ejemplo, mostrará que tiene a esos dos archivos,
<em>archivo1.md</em> y <em>archivo2.md</em>. Sin embargo, si lo abre con
una carpeta (también llamada directorio), por ejemplo,</p>
<pre><code>$ vim dir</code></pre>
<p>en principio tendrá la lista de argumentos vacía. La forma de añadir
archivos a la lista de argumentos es con</p>
<pre class="vim"><code>:args &lt;archivos&gt;</code></pre>
<p>donde <code>&lt;archivos&gt;</code> es una lista de archivos
separados por espacios. O podría ser una ruta, como, por ejemplo,
<code>**/*.rb</code> para que añada todos los archivos con extensión
<em>.rb</em>, de forma recursiva, tal y como indica la parte
<code>**/</code>. O podría usar un comando dentro, introduciéndolo entre
acentos graves; por ejemplo,</p>
<pre class="vim"><code>:args `find . -type f`</code></pre>
<p>que añadiría todos los archivos dentro de esa carpeta; no añadiría
carpetas. El problema creo que está en que no se pueden expandir los
comodines, además de que así es más complicado de forma innecesaria.</p>
<p>En cualquier caso, puede buscar del modo fácil usando la recursión.
Por ejemplo,</p>
<pre class="vim"><code>:args **/*.md</code></pre>
<p>para buscar todos los archivos con la extensión de nombre de archivo
<em>.md</em>, que es la que suelen tener los archivos Markdown.</p>
<p>Para añadir o quitarle archivos a la lista de argumentos, se puede
usar <code>:argadd</code> y <code>:argdelete</code>, respectivamente.
Así, podrá trabajar sobre una lista parcial y no tendrá que añadirlo
todo desde cero.</p>
<p>Una vez que tiene la lista de argumentos que desee, deberá usar el
comando <code>argdo</code> seguido de un comando de Vim, para realizar
la acción que desee sobre dichos archivos. Por ejemplo,</p>
<pre class="vim"><code>:argdo %s/&lt;search&gt;/&lt;replace&gt;/ecg | update</code></pre>
<p>Quizás le interese que no le muestre los errores <q><em>pattern not
found</em></q>. Para eso está la bandera <code>e</code> del final. La
parte <code>| update</code> es para que guarde automáticamente los
archivos que cambie. En caso de no usarla, puede confirmar luego la
escritura de todos esos archivos que ha modificado uno por uno o, si lo
prefiere, de golpe, con <code>:wall</code>.</p>
<p>De todos modos, cualquier acción que desee realizar sobre varios
archivos desde el editor podrá hacerla, alternativamente, desde el
<em>shell</em>, que quizás sería la forma más adecuada. También, puede
lanzar desde Vim o Neovim un comando del <em>shell</em>, poniendo el
nombre de este precedido de un signo de cierre de exclamación
(<code>!</code>). Por ejemplo,</p>
<pre class="vim"><code>:!ls</code></pre>
<p>mostraría los contenidos de la carpeta en el <em>shell</em>; no los
<em>buffers</em> abierto en el editor.</p>
<hr />
<p>Lo cierto es que no sé cómo unir los comandos <code>args</code> y
<code>vimgrep</code>. Sí sé cómo se unirían <code>args</code> y
<code>grep</code>, siendo este un comando del <em>shell</em>. Se hace,
tal y como se incluyen siempre en Ex los comandos de <em>shell</em>:
encerrándolos entre backticks. Por ejemplo,</p>
<pre class="vim"><code>:args `grep -Rl \.plugin **/*.djot`</code></pre>
<p>Así, se habrán añadido a la lista de argumentos los archivos que
hayan pasado ese filtro; concretamente, en este ejemplo, los que
contienen la cadena <code>.plugin</code> y que tienen extensión (de
nombre de archivo) <em>.djot</em>.</p>
<p>Luego, es momento de actuar sobre todos estos. Por ejemplo,</p>
<pre class="vim"><code>argdo %s/\.plugin/.plgn/ecg</code></pre>
<p>Así, se sustituirán las cadenas <code>.plugin</code> por
<code>.plgn</code> en todos los archivos de la lista de argumentos.
Gracias a la opción <code>c</code> del comando de sustitución
(<code>s</code>), nos pedirá una confirmación para cada coincidencia.
Además, gracias a la opción <code>g</code> se podrá tener más de una
coincidencia en una misma línea. Irá moviéndose por sí solo entre los
distintos archivos.</p>
<p>Tras esto, se deberán guardar los cambios en todos y cada uno de los
archivos que hemos modificado. Es tan sencillo como <code>:wa</code>, o
<code>:xa</code> si desea salir también automáticamente tras esto (que
sería equivalente a `<code>waq</code>).</p>
<hr />
<p>Para realizar una acción sobre todos los elementos de la lista
<em>quickfix</em>, se tiene el comando <code>:cdo</code> o
<code>:cfdo</code>.</p>
<p><a href="https://www.youtube.com/watch?v=F3ZfdeAWP2Y"
class="uri">https://www.youtube.com/watch?v=F3ZfdeAWP2Y</a></p>
</section>
<section id="edición-remota" class="level2">
<h2>Edición remota</h2>
<p>Se puede hacer de varias formas. Por ejemplo, podríamos mapear un
directorio de la máquina remota en nuestro sistema. Así, podríamos
editar <q>localmente</q> los archivos en el directorio. El problema es
que tendríamos que tener también abierta una sesión remota de
<em>shell</em> (típicamente, con SSH), para introducir comandos en la
máquina remota; por ejemplo, para compilar o para otras cosas.</p>
<p>Existe también de hacer en Vim una edición remota más propiamente
dicha, parecida a lo que se consigue con el modo Tramp en Emacs o con la
edición remota de VSCode. Encontré una <a
href="https://stackoverflow.com/a/601684/7026520">explicación de cómo
configurarlo</a>. Lo cierto es que no me termina de convencer. Sigue
siendo un incordio si se compara con la edición remota de VSCode.</p>
<p>Hay que tener en cuenta también una cosa con respecto a la edición
remota. ¿Para qué se hace? En principio, imagino que para no sobrecargar
el sistema y por razones de seguridad: es aconsejable instalar la menor
cantidad posible de <em>software</em> en un servidor para limitar la
superficie de ataque. Pues bien, con la edición remota, nos estamos
saltando esto en cierto modo, pues, al estar editando en nuestra máquina
personal, es como si hubiésemos instalado ese mismo <em>software</em> de
edición en el servidor. Por esto creo que es mejor tener una
configuración básica de Vim y Bash en algún repositorio de GitHub y usar
Vim directamente en la máquina remota con esa configuración. Aunque,
bueno, pensándolo bien, Vim y Neovim como <em>software</em> se trata de
proyectos algo complejos, con lo que también podrían tener
vulnerabilidades.</p>
</section>
<section id="inserción-múltiple" class="level2">
<h2>Inserción múltiple</h2>
<p>Antes, solía usar el modo bloque visual<a href="#fn10"
class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>
(<em>visual block</em>) para hacer este tipo de cosas: inserción
múltiple, por ejemplo, insertar cierto texto al comienzo de varios
renglones contiguos. Lo que haría sería</p>
<ol>
<li>Entrar al modo bloque visual (con la combinación <kbd>Ctrl</kbd> +
<kbd>v</kbd>),</li>
<li>Seleccionar una o más columnas de texto que cubran todos los
renglones que me interesan,</li>
<li>Pulsar <kbd>Shift</kbd> + <kbd>i</kbd>,</li>
<li>Escribir lo que desea añadir a todos los renglones y, cuando haya
terminado,</li>
<li>Pulsar <kbd>Esc</kbd>.</li>
</ol>
<p>Luego, aprendí otra forma de hacerlo de un modo que me gusta más,
además de que es más versátil, es decir, nos permitirá hacer otros tipos
de cosas, no solo introducir texto al comienzo. El método sería
seleccionando en modo de línea visual (<em>visual line</em>) varios
renglones de texto (ojo, no bloque visual) y luego introduciendo un
comando en la línea, que se aplicará a todos los renglones. Para el
ejemplo de antes sería:</p>
<ol>
<li>Entrar, en el primero de los renglones, a modo línea visual y bajar
hasta tener seleccionados todos los que le interesen.</li>
<li>Pulsar <kbd>:</kbd>. Estará editando la línea de abajo y, al estar
editando sobre una línea visual, aparecerá, al lado del símbolo de dos
puntos, <code>'&lt;,'&gt;</code>.</li>
<li>Ahora, añada el <code>COMANDO</code> que desee aplicar:
<code>:'&lt;,'&gt;COMANDO</code>. Si se trata de introducir texto al
comienzo, podría ser <code>:'&lt;,'&gt;normal 0iTEXTO</code>, donde
<code>TEXTO</code> es el texto que desea añadir al comienzo de los
renglones.</li>
<li>Pulse <kbd>Intro</kbd>.</li>
</ol>
</section>
<section id="editar-al-final-de-varios-renglones" class="level2">
<h2>Editar al final de varios renglones</h2>
<p>Se podría hacer en modo bloque visual. El procedimiento sería:</p>
<ol>
<li>Sobre uno de los renglones de interés, se entra en modo bloque
visual (con <kbd>Ctrl</kbd> + <kbd>v</kbd>).</li>
<li>Se seleccionan varias columnas (da igual el número) de los renglones
que interesen.</li>
<li>Se pulsa <kbd>$</kbd>. Luego, <kbd>Shift</kbd> + <kbd>a</kbd>.</li>
<li>Se introduce la letra que se desee, que aparecerá, de momento, solo
en uno de los renglones.</li>
<li>Se pulsa <kbd>Esc</kbd>.</li>
</ol>
<p>Aun así, prefiero hacer uso del modo línea visual y Ex, pues permite
más cosas.</p>
</section>
<section id="patrones" class="level2">
<h2>Patrones</h2>
<p>Los <a href="https://neovim.io/doc/user/pattern.html">patrones</a>
(<em>patterns</em>), más concretamente, las expresiones regulares
(<em>regular expressions</em> o, abreviadamente, <em>regexes</em>), se
usan bastante a menudo en Vim y Neovim. Un ejemplo es en las búsquedas y
los reemplazos en la edición, aunque posiblemente también los verá en
otras situaciones.</p>
<p>Como seguramente sepa, existen varios tipos de <em>regexes</em>. De
forma predefinida, Vim y Neovim usan unas bastante antiguas. Si desea
forzar que se use un tipo de <em>regexes</em> más moderno, puede
emplear, al comienzo de esta, el dígrafo <code>\v</code>, lo cual indica
que se trata de una <em>very magic regex</em>. Aun así, estas creo que
tampoco son como las que se suelen usar en el IDE VSCode o en algunos
lenguajes modernos como Python.</p>
<p>Existe un <em>plug-in</em> para que se ponga el modo <em>very
magic</em> automáticamente cuando se va a usar una <em>regex</em>, pero
creo que en ciertos casos no funciona; por ejemplo, en la <a
href="#actuar-sobre-varios-archivos">lista de argumentos</a>.</p>
<p>Lo ideal sería que se permitiera configurar para todo el editor el
tipo de <em>regex</em> que se use de forma predeterminada, pero esto
creo que no se puede. Existe un <em>plug-in</em> llamado Loupe para
hacer esto, pero en ciertas situaciones no podrá usar las
<em>regexes</em> nuevas, con lo que se pierde coherencia en el
comportamiento del editor.</p>
<p>Una de las particularidades de las <em>regexes</em> de Vi y Neovim
es, por ejemplo, que la demarcación de <em>non-greedy</em> es algo
distinta a las <em>regexes</em> modernas. En estas últimas, se haría
usando el sígno de cierre de interrogación; por ejemplo, algo así
<code>.*?</code>. En Vim y Neovim, sin embargo, habría que poner el
complementario TKTK. Por ejemplo, <code>.[^}]*</code>.</p>
<hr />
<p>En lo que respecta a las expresiones regulares, siempre hay que tener
en cuenta a qué tipo en concreto de sintaxis de estas se usa. En el caso
de VSCode, creo que se siguen la sintaxis Oniguruma, que es la misma que
usa el lenguaje Ruby. En Vim, creo que se usan las de Perl. Además, de
forma predeterminada se tienen las antiguas. Si se desea, se puede usar
la moderna, anteponiendo con <code>\v</code>.</p>
<p>Por ejemplo, una diferencia es la forma de marcar que una expresión
sea <em>reticente</em> (<em>reluctant</em> o <em>non-greedy</em>). De
forma predeterminada sí lo son. Esto quiere decir que se tomará el
encaje (<em>match</em>) mayor posible. En caso de querer hacerla
reticente, es decir, que tome el más pequeño, la sintaxis que se usa
será distinta en VSCode y en Vim. En VSCode, por ejemplo, se podría
hacer <code>.*?</code>. Ese signo de cierre de interrogación
(<code>?</code>) es el que marca que sea reticente. En Vim, podría
hacerse algo así TKTK. Puede consultarlo en la entrada <a
href="https://neovim.io/doc/user/pattern.html#non-greedy"><code>non-greedy</code></a>
en la ayuda oficial de Neovim. En Vim y Neovim, por su parte, deberá
poner entre corchetes un símbolo que no desee que se incluya. Por
ejemplo, la siguiente expresión regular para buscar haría que se busquen
cadenas entre llaves pero de forma <em>non-greedy</em>, es decir, las
menores posibles.</p>
<pre><code>/{.[^}]*}</code></pre>
<p><a href="https://macromates.com/manual/en/regular_expressions"
class="uri">https://macromates.com/manual/en/regular_expressions</a></p>
<hr />
<p>El mejor manual de cómo usar las regex de Vim y Neovim, que, por
cierto, son una pasada, es el de <a
href="http://vimregex.com/">vimregex</a>. No se asuste por la estética
tan fea de esa web; merece la pena seguir el tutorial.</p>
<p>Las <em>regex</em> no son solo para buscar y reemplazar, aunque esos
son unos propósitos muy importantes. También se usan para crear archivos
de resaltado de código de lenguajes, en la forma tradiciona (la forma
moderna sería con Tree-Sitter, que no se basa en <em>regexes</em>).</p>
<p>También, está bien <a
href="https://www.reddit.com/r/vim/comments/cz1upx/substitute_in_vim/">esto</a>,
para aprender lo básico de las sustituciones.</p>
</section>
<section id="formatear-código" class="level2">
<h2>Formatear código</h2>
<p>Vim, y, por tanto, también Neovim, cuenta con muchos ajustes a la
hora de formatear código. Al ser más <em>hackeable</em> o
<em>scriptable</em> que los IDEs, se pueden especificar hasta un gran
detalle el comportamiento en lo que respecta al formateado de
código.</p>
<p>Por ejemplo, algo que quizás no encuentre en los IDEs es el
formateado para lenguajes de marcado, como por ejemplo Markdown o
reStructuredText.</p>
<p>Por lo que veo, en VSCode estos ajustes <a
href="https://stackoverflow.com/a/58246538/7026520">deberá
especificarlos en el formateador que corresponda</a>, que es una
herramienta externa a VSCode. Además, el formateado se hará, en VSCode,
lanzándolo usted mismo; al contrario de Vim, que puede hacer que se
realice sobre la marcha mientras escribe.</p>
<p>En Vim (y Neovim), los ajustes de formateado se hacen con la variable
<code>formatoptions</code>. Los valores que puede tener esta vienen
explicados en <a
href="https://neovim.io/doc/user/change.html#fo-table">esta lista</a>.
De forma predeterminada, en Neovim tiene por valor a
<code>tcqj</code>.</p>
<p>Personalmente, suelo poner de forma predeterminada, como base, a
<code>cqj</code> y luego voy modificándolo para los distintos lenguajes
con autocomandos. Para C, tengo <code>cqj2n</code>. Para Markdown,
<code>tcqj2n</code>. Lo que no me gusta es usar la opción
<code>a</code>, que hace constantemente el formateado. Me gusta tener la
opción de corregir el formateado en ciertas partes <q>a mano</q>. Quizás
lo use si en un futuro hay algún formateador de código que contemple
todos los aspectos que uso TKTK.</p>
<p>En Markdown, antes era un incordio usar la opción de formateado
<code>n</code>, pero ahora creo que lo han corregido. Podía suceder algo
como lo siguiente:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode markdown"><code class="sourceCode markdown"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>El formateado de texto puede ser incorrecto si a final de oración tenemos un</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>En este caso, en algunos formateadores de código se interpreta como un</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>   elemento de una lista numerada, con lo que deja un espacio en el renglón</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>   siguiente, así como en los demás que le siguen.</span></code></pre></div>
<p>Es decir,el formateador interpretaba ese <code>2.</code> como el
comienzo de un elemento de una lista numerada en Markdown. Creo que
ahora el formateador es más <q>inteligente</q>.</p>
<p>Esto es algo que está tratando de corregir el lenguaje Djot. En este,
cada línea de inicio de un elemento de una lista debe ir en una línea
separada del elemento anterior.</p>
<hr />
<p>Otra cosa importante sobre el formateado. La variable
<code>formatprg</code> establece cuál es el <em>software</em> externo a
Neovim que se usará para hacer el formateo con <code>gq</code>.</p>
<p>Un <em>software</em> que puede usarse ahí es la herramienta de Unix
<code>fmt</code>, por ejemplo.</p>
<p>También, es importante que consulte la documentación de la variable
<code>formatexpr</code>.</p>
<p>También, es interesante echar un ojo, para los LMLs, a la variable
<code>formatlistpat</code>.</p>
<hr />
<p>Un <em>plug-in</em> muy moderno sobre el formateado es [Confofm][],
<a href="https://www.youtube.com/watch?v=XvGpB-wmOUA">recomendado por
Alpha Developer</a>. Este permite más versatilidad a la hora de
seleccionar el formateador para un lenguaje en concreto. Personalmente,
creo que no me merece mucho la pena instalar un <em>plug-in</em> para
esto.</p>
</section>
<section id="vimgrep" class="level2">
<h2>Vimgrep</h2>
<p>Neovim trae integrada de serie la herramienta <code>grep</code>. Se
llama <code>vimgrep</code>. Como quizás ya sepa, nada le impide usar
cualquier <em>software</em> de la línea de comandos en Vim. No tiene más
que preceder, en el editor Ex, el nombre del comando por el signo de
cierre de exclamación (<code>!</code>). La diferencia está en que
<code>vimgrep</code> está más integrado con el propio Neovim.</p>
<p>Gracias a <code>vimgrep</code> y a <code>find</code> (me refiero a
los comandos de Neovim; no a los del <em>shell</em>), puede tener algo
parecido, sin necesidad de instalar nada, a lo que se suele obtener con
el <em>plug-in</em> Telescope.</p>
<p>En realidad, el uso de <code>vimgrep</code> no es nada complicado, si
ya se sabe usar <code>grep</code>. En cualquier caso, TKTK.</p>
<p>Para buscar algo por <code>vimgrep</code>, debe usar el comando</p>
<pre class="vim"><code>:vimgrep &lt;regex&gt; &lt;rutas&gt;</code></pre>
<p>Una vez ejecutado el comando, debajo de la barra de estado aparecerá
el número de coincidencias. Luego, debe usar el comando
<code>:cope</code> y se mostrarán en una ventana aparte los distintos
resultados de las coincidencias. En esta, puede ir moviéndose y, para
abrir una que desee, pulsar <kbd>Intro</kbd>.</p>
<p>Como siempre, puede moverse entre ventanas con <kbd>Ctrl</kbd> +
<kbd>w</kbd> + <kbd>Ctrl</kbd> + <kbd>w</kbd>.</p>
</section>
<section id="autocompletado-copiando-texto" class="level2">
<h2>Autocompletado copiando texto</h2>
<p>Una funcionalidad muy útil que le puede hacer muy cómoda la edición
es que el autocompletado tiene varios modos. En concreto, uno de ellos
es el autocompletado copiando texto del mismo archivo. Esto se explica
en la entrada <code>ins-completion</code>, en la ayuda oficial.</p>
<p>Veamos cómo funciona. Suponga que tiene un archivo abierto en una
ventana del editor y en dicho archivo hay un renglón como el
siguiente:</p>
<pre><code>... es bueno tomar pausas pequeñas durante el aprendizaje</code></pre>
<p>Entonces, para escribir eso mismo en otra parte del archivo,
comenzamos escribiendo lo mismo (evidentemente, en modo insert):</p>
<pre><code>es buen</code></pre>
<p>entonces, hacemos el autocompletado de la palabra, como estamos
acostumbrados: <kbd>Ctrl</kbd> + <kbd>n</kbd> (también, valdría
<kbd>Ctrl</kbd> + <kbd>p</kbd>, para el sentido opuesto). Seleccionamos
así, de entre las opciones que aparezcan, la adecuada; en este caso,
<code>bueno</code>. Ahora, no le damos a que lo inserte, sino que
inmediatamente después usamos la combinación <kbd>Ctrl</kbd> +
<kbd>f</kbd> <kbd>Ctrl</kbd> + <kbd>p</kbd>. Así, nos aparecerá como
opción de autocompletado una cadena de dos palabras; en este caso,
<code>bueno tomar</code>. Vamos repitiendo sucesivamente esta última
combinación (<kbd>Ctrl</kbd> + <kbd>f</kbd> <kbd>Ctrl</kbd> +
<kbd>p</kbd>) y vamos completando la cadena tal y como estaba antes.
Creo que puede ser <kbd>n</kbd> en lugar de <kbd>p</kbd>, a partir de
cierto punto. Esto irá copiando el mismo texto.</p>
<p>Puede suceder que tengamos dos cadenas que comienzan igual pero a
partir de cierto punto son diferentes. En dicho caso, tendremos que
operar como antes pero con cautela para seleccionar, en el momento en el
que se hacen diferentes, la que deseamos.</p>
<p>Creo que no funciona cuando hay algún símbolo extraño, como un
<em>backtick</em>.</p>
</section>
<section id="macros" class="level2">
<h2>Macros</h2>
<p>Los macros son una herramienta muy útil que trae Vim de forma
predeterminada, es decir, no necesitará instalar una extensión para
poder usarlos.</p>
<p>Para crear un macro, deberá, en modo normal, pulsar <kbd>q</kbd>
seguida de una letra que identifique al macro, , pulsaría <kbd>q</kbd>
<kbd>Y</kbd>, donde aquí <kbd>Y</kbd> indica la letra identificativa de
un macro, que puede ser cualquiera de las letras del alfabeto
internacional (en español, se excluye la <em>ñ</em>). Imagino que la
letra <em>q</em> también está excluida, al ser la que se usa para
iniciar y terminar el macro. Verá que, en la esquina inferior izquierda
de Vim, se le mostrará un mensaje indicando que se está grabando un
macro. Por ejemplo, si está creando un macro con identificativo
<code>e</code>, pondría <code>recording @e</code>.</p>
<p>Todo lo que haga ahora se guardará como parte del macro: cualquier
movimiento, eliminación de texto, añadir texto, etc. Dentro de la
grabación del macro, puede entrar y salir de los distintos modos sin
preocuparse: puede pasar a modo <em>insert</em>, a <em>normal</em>, a
<em>visual block</em>, etc. Para terminar la grabación, basta con que
pulse <kbd>q</kbd> de nuevo en modo <em>normal</em>. Esa es una
limitación, por tanto: no podrá introducir <kbd>q</kbd> en modo normal
durante la grabación del macro, a menos que desee parar la grabación. De
todos modos, creo que <kbd>q</kbd>, por esta razón, está reservado solo
para el inicio y fin de macro en Vim. Es decir, no tiene otras funciones
en el modo <em>normal</em> de Vim.</p>
<p>Una ver hecha la grabación del macro, para repetir la edición que
realizó durante la grabación —aunque en otra parte del texto; ahí está
la gracia de usar un macro—, deberá introducir, en modo normal, arroba y
luego el designador del macro. Por ejemplo, para el macro
<code>e</code>, sería <kbd>@</kbd> <kbd>e</kbd> (<code>@e</code>).</p>
<p>En total, se pueden tener 26 macros: designados de la <code>A</code>
a la <code>Z</code> del alfabeto internacional (por lo tanto, no se
puede designar por <code>Ñ</code> a ninguno). En realidad, hay más, pero
para propósitos especiales.</p>
</section>
<section id="retazos" class="level2">
<h2>Retazos</h2>
<p>Los retazos (<em>snippets</em>) son una herramienta algo útil que
implementó por primera vez el editor TextMate (creado por la empresa
Apple) y que actualmente usan casi todos los editores e IDEs. Consiste
en, a partir de cierto rango de entrada de texto en el editor,
desencadenar la opción de autocompletar. TKTK.</p>
<p>No obstante, aunque durante algún tiempo he usado bastante los
retazos, ahora considero que es algo que se debe evitar. Creo que, si se
usan retazos es porque el lenguaje que se está usando es
innecesariamente enrevesado. Además, considero que no se debe delegar
mucho TKTK.</p>
<p>Tradicionalmente, Vim y Neovim no han traído de serie funcionalidades
de retazos, y, para tenerlos, era necesario recurrir a algún
<em>plug-in</em>. Esto, al parecer, ahora ya no es así, pues ahora <a
href="https://github.com/neovim/neovim/pull/25301">han integrado en el
<em>core</em> de Neovim la funcionalidad de retazos</a>. No obstante, se
trata de una funcionalidad muy básica, por lo que los <em>power
users</em> de los retazos creo que seguirán usando <em>plug-ins</em>
para esta funcionalidad.</p>
<p>El <em>plug-in</em> de retazos más popular en la actualidad en el
ecosistema de Neovim es <a
href="https://github.com/L3MON4D3/LuaSnip">LuaSnip</a>.</p>
<p>Lo cierto es que no soy muy fanático de los retazos, pero parece que
hay gente que sí les saca mucho partido. Por ejemplo, puede ver el uso
que hace de estos, usando el <em>plug-in</em> Ultisnips, un chico que <a
href="https://castel.dev/post/lecture-notes-1/">toma apuntes al vuelo en
LaTeX</a> en sus clases del grado universitario de matemáticas.</p>
<p>Hay que decir también que existen cosas que son como los retazos pero
llevándolos algo más al extremo. Hablo de Emmet, en el editor
VSCode.</p>
</section>
<section id="registros" class="level2">
<h2>Registros</h2>
<p>Creo que el mejor tutorial sobre el uso de registros es <a
href="https://www.youtube.com/watch?v=I5QGlfbuCfs">este</a>.</p>
<p>Lo primero que debe conocer es el comando para consultar todos los
registros que tiene en ese instante. Dicho comando es
<code>:registers</code> o, de forma abreviada, <code>:reg</code>.</p>
<p>Al lanzarlo, le aparecerá una ventana emergente con una lista con
todos los registros que tiene. Los nombres de los registros comienzan
siempre por un signo de comillas dobles (<code>"</code>). Tras dicho
signo, el nombre será un número, una letra o algún otro signo. Según el
tipo de carácter que acompañe a las comillas dobles, el registro tendrá
un significado, que explicamos más adelante.</p>
<p>Para acceder a un registro, la forma de hacerlo dependerá del modo en
el que se encuentre. Si está en modo normal, tendrá que poner el nombre
del registro seguido de la acción que desee realizar sobre este. Por
ejemplo, para pegar en el texto el registro con nombre <code>"1</code>,
será tan sencillo como introducir <kbd>”</kbd> <kbd>1</kbd> <kbd>p</kbd>
(es decir, <code>"1p</code>).</p>
<p>Otro ejemplo, para copiar en el registro <code>a</code> la palabra en
la que se encuentra el cursor en modo normal, sería <kbd>”</kbd>
<kbd>a</kbd> <kbd>y</kbd> <kbd>i</kbd> <kbd>w</kbd> (o sea,
<code>"ayiw</code>).</p>
<p>Para pegar el contenido de registro, cuando nos encontramos en modo
insert, se debe anteponer al designador del registro la combinación
<kbd>Ctrl</kbd> + <kbd>r</kbd>. Por ejemplo, para pegar el contenido del
registro 1, <kbd>Ctrl</kbd> + <kbd>r</kbd> <kbd>1</kbd>
(<code>^r1</code>).</p>
<hr />
<p>Debe saber también que el registro <code>""</code> es el registro sin
nombre (<em>unnamed register</em>). Cuando copia algo con <kbd>y</kbd>
<kbd>y</kbd> (<code>yy</code>), el texto que ha copiado aparecerá en el
registro sin nombre.</p>
<p>En realidad, son más acciones las que almacenan datos en el registro
sin nombre. Todo lo que se haga con <code>d</code>, <code>c</code>,
<code>s</code>, <code>x</code>, <code>y</code>; y sus versiones en
mayúsculas. Por su parte, <code>p</code> y <code>P</code> pegan lo que
hay en el registro sin nombre; no es necesario especificar el designador
del registro.</p>
<p>Según la acción de estas que realice, además del registro sin nombre,
se almacenará esa información en otro registro. Por ejemplo, si hace
<code>dd</code> sobre una línea de texto, también se almacenará en el
registro 1. Si hace <code>yy</code>, en el 0.</p>
<p>Conforme vaya borrando más cosas, estas irán apareciendo en el
registro 1 y, la que estaba antes en dicho registro, se pasa al 2.
Luego, en el siguiente borrado, se pone en el 1 y lo que había en el 1
se pasa al 2 y lo que había en el 2 al 3. Y así sucesivamente hasta el
9.</p>
<p>Lo único que tiene que tener en cuenta con esto es que hay ciertos
movimientos que hacen que no cuente como una operación de borrado. Por
ejemplo, <code>%</code>, <code>( )</code>, etc.</p>
<hr />
<p>En lo que respecta a los registros que se identifican con una letra
(en total, se tienen 26), ahí se almacenan automáticamente, por ejemplo,
los [macros] que creamos. El identificativo del macro en realidad se
refiere al del registro donde se almacenará. Sabiendo esto, podremos
editar un macro si nos equivocamos al construirlo, sin necesidad de
reconstruirlo por completo desde el principio.</p>
<p>Un macro se editaría haciendo lo siguiente. Suponga que nos referimos
al macro en el registro <code>a</code>. Entonces, tendríamos que
hacer</p>
<pre class="vim"><code>let @a=&#39;&#39;</code></pre>
<p>y poner entre esas comillas lo que deseemos introducir. Pero si el
macro ya lo había creado, puede poner su cursor entre las comillas e
insertar el contenido como ya hemos dicho cuando está en modo insert
(<kbd>Ctrl</kbd> + <kbd>r</kbd> <kbd>a</kbd>). Luego, sobre eso, hará
las modificaciones que desee. Debe tener también en cuenta que ahí
aparecerá la orden de la tecla <kbd>Esc</kbd> como <code></code>, que,
aunque se parezca a un gorro seguido de apertura de corchetes,
<code>^[</code>, no lo es. El símbolo que queremos se introduce, en modo
insert, con <kbd>Crtl</kbd> + <kbd>v</kbd> <kbd>Esc</kbd>.</p>
<p>Registros de solo lectura.</p>
</section>
<section id="ampliar-la-selección-visual" class="level2">
<h2>Ampliar la selección visual</h2>
<p>Al tener hecha una selección visual de caracteres (no de línea,
<em>visual line</em>), con <kbd>o</kbd> puede ir moviéndose, en la
selección al otro extremo. Por ejemplo, con <kbd>v</kbd> comienza, es
decir, entra al modo visual. Entonces, se moverá hasta la parte derecha,
hasta donde quiera que llegue. Pero si introduce <kbd>o</kbd>, se irá al
comienzo, desde donde empezó la selección, y podrá mover por ese lado la
selección también.</p>
</section>
<section id="configuración-específica-de-proyecto" class="level2">
<h2>Configuración específica de proyecto</h2>
<p>En Vim existe, desde hace bastante, una funcionalidad llamada
<em>modelines</em> que permite hacer ajustes de Vim para un archivo en
particular (son ajustes que <q>pisan</q> los de su configuración). Las
<em>modelines</em> se especifican en comentarios. Se pone primero el
signo de apertura de comentario del lenguaje del que se trate (en el
archivo), seguido de <code>vim:</code> y seguido del ajuste de Vim que
desee añadir. Por ejemplo, con algo así al final de un documento de
TeX:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode tex"><code class="sourceCode latex"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">% vim: fdm=syntax</span></span></code></pre></div>
<p>Esto tiene sus inconvenientes y creo que no es una solución válida
para especificar unos ajustes para todo un proyecto. Por ejemplo, está
ensuciando los archivos con cosas que no le interesarán a gente que use
otros editores. Además, debe poner esas <em>modelines</em> en todos los
archivos, lo cual hace que sea un incordio.</p>
<p>Lo ideal sería encontrar algo como lo que se puede hacer, por
ejemplo, en el editor VSCode. En este, se puede especificar unos ajustes
locales simplemente con la carpeta oculta <em>.vscode</em> en la raíz
del proyecto.</p>
<p>A este respecto, existen <a
href="https://vi.stackexchange.com/a/20908/22600">varias soluciones</a>,
pero considero que estas están algo anticuadas. La forma que creo que es
actualmente la más cómoda y elegante es con el <em>plug-in</em> <a
href="https://github.com/folke/neoconf.nvim"
class="plgin">Neoconf</a>.</p>
<hr />
<p>Bueno, creo que ahora Neovim <a
href="https://neovim.io/doc/user/editorconfig.html">trae soporte nativo
para EditorConfig</a>. De hecho, esta es la forma con la que me quedaría
actualmente, aunque únicamente es válida para ajustes que puedan ser
comunes para los distintos editores que se vayan a usar; cosas como la
indentación, etc. De hecho, se podría considerar a EditorConfig como una
especificación de ajustes de los editores e IDEs; no una implementación;
habrá una por cada editor o IDE.</p>
<hr />
<p>Creo que se puede especificar también una configuración específica
mediante los entornos de desarrollo, como <code>venv</code> de Python o
con el gestor de paquetes Nix. O quizás solo interese cierta
configuración que se añada a la básica que ya tengo. No sé cómo se haría
y tampoco estoy seguro de que se pueda hacer.</p>
</section>
<section id="acciones-avanzadas" class="level2">
<h2>Acciones avanzadas</h2>
</section>
<section id="macro-sobre-regex" class="level2">
<h2>Macro sobre <em>regex</em></h2>
<p>Por ejemplo, el macro almacenado en el registro <code>o</code> y
<code>pattern</code> sería la regex:</p>
<pre class="vim"><code>:g/pattern/norm @o</code></pre>
</section>
<section id="deshacer-con-ramas" class="level2">
<h2>Deshacer con ramas</h2>
<p>Referencias:</p>
<ul>
<li><a href="https://advancedweb.hu/2017/09/12/vim-using-undo-branches/"
class="uri">https://advancedweb.hu/2017/09/12/vim-using-undo-branches/</a></li>
<li><a href="https://vim.fandom.com/wiki/Using_undo_branches"
class="uri">https://vim.fandom.com/wiki/Using_undo_branches</a></li>
</ul>
<p>Esta es una funcionalidad que el gran Bram Moolenaar añadió a Vim en
su versión 7.0 y a la que creo que se puede sacar mucho partido.
Consiste en usar un árbol (<em>tree</em>) en lugar de una pila
(<em>stack</em>) en los hitos de edición, que es lo que se hacía antes y
lo que se suele hacer en los demás editores e IDEs (con la notable
excepción de Emacs).</p>
<p>Tal y como ya sabrá, con <kbd>u</kbd> y <kbd>Ctrl</kbd> +
<kbd>r</kbd> se hace <em>undo</em> y <em>redo</em>, respectivamente.
Ahora, esto se sigue usando pero para moverse por la rama principal…
pero existen formas de cambiar de ramas.</p>
<p>Pero ¿a qué me refiero con <em>ramas</em> (<em>branches</em>)?
Veámoslo con un ejemplo práctico. Suponga que se encuentra editando lo
siguiente:</p>
<pre class="vim"><code>Punto 1.

Punto 2.

Punto 3.</code></pre>
<p>Debe editarlo de tal forma que, tras editar una línea, se ponga en
modo normal y pase a editar en modo insert la siguiente. Es decir,
escribe primero <code>Punto 1</code>, luego sale a modo normal y luego
TKTK.</p>
<p>Ahora, deshacemos el último cambio, con <kbd>Ctrl</kbd> +
<kbd>r</kbd>:</p>
<pre class="vim"><code>Punto 1.

Punto 2.</code></pre>
<p>y editamos la última línea de un modo distinto:</p>
<pre class="vim"><code>Punto 1.

Punto 2.

Punto 4.</code></pre>
<p>Entonces, en esta situación, en principio, haciendo undo y redo, no
podemos volver al estado inicial, es decir, a</p>
<pre class="vim"><code>Punto 1.

Punto 2.

Punto 3.</code></pre>
<p>Pruébelo si lo desea. Esto se debe a que la rama principal es ahora
la que nos lleva al estado siguiente:</p>
<pre class="vim"><code>Punto 1.

Punto 2.

Punto 4.</code></pre>
<p>Para ir al estado donde aparece <code>Punto 3</code>, tendríamos que
cambiar de rama. Existe una forma mediante la que puede moverse por el
histórico de ediciones de forma cronológica. Se hace con <kbd>g</kbd>
<kbd>-</kbd> y <kbd>g</kbd> <kbd>+</kbd>. Puede hacer la prueba: con
<kbd>g</kbd> <kbd>-</kbd> y <kbd>g</kbd> <kbd>+</kbd>, puede moverse por
todo el histórico, de tal forma que pasará por todos los estados de
edición en los que se ha encontrado el archivo que está editando.</p>
</section>
<section id="multicursores" class="level2">
<h2>Multicursores</h2>
<p>No sé si son algo realmente útil. Creo que no. Para empezar, creo que
todo lo que veo que se hace con multicursores se puede hacer con macros.
También, hay quien se ha tomado la molestia de coleccionar <a
href="https://vonheikemen.github.io/devlog/tools/how-to-survive-without-multiple-cursors-in-vim/">formas
alternativas de hacer lo mismo</a>.</p>
<p>No sé si lo llegarán a integrar de serie. En cualquier caso, existe
algún <em>plug-in</em> como <a
href="https://github.com/smoka7/multicursors.nvim"><code>multicursors.nvim</code></a>.</p>
<p>En cualquier caso, creo que es mucho más interesante las acciones
sobre objetos mediante Tree-Sitter.</p>
</section>
<section id="autocomandos" class="level2">
<h2>Autocomandos</h2>
<p>Uno de los ajustes más interesantes de Neovim son los autocomandos
(<em>autocommands</em>). Estos nos permiten lanzar comandos según
ciertos eventos (<em>events</em>). TKTK. Evidentemente, sirven para
automatizar acciones en nuestro uso de Neovim.</p>
<p>Puede ver <a href="https://www.youtube.com/watch?v=qN6BuJpsFbQ">un
tutorial</a> o <a
href="https://www.youtube.com/watch?v=qN6BuJpsFbQ&amp;t=1s">este
otro</a>.</p>
<p>También, puede consultar la entrada <a
href="https://neovim.io/doc/user/autocmd.html"><code>autocmd</code></a>
de la documentación oficial de Neovim.</p>
<p>Hasta hace poco, incluso en Neovim se tenían que especificar con la
sintaxis de Vim, es decir, en el lenguaje Vimscript. Sin embargo, ahora
ya se puede mediante la API para poder hacer la configuración en
Lua.</p>
<p>La función para definir un autocomando directamente en Neovim es</p>
<pre class="vim"><code>:autocmd [&lt;grupo&gt;] &lt;evento&gt; &lt;patrón&gt; &lt;comando&gt;</code></pre>
<p>Se trata, por tanto, de una función con parámetros posicionales. Como
indican los corchetes, el parámetro <code>&lt;grupo&gt;</code> es
opcional. Los demás que están encerrados entre <code>&lt;&gt;</code> son
<em>placeholders</em>, es decir, deberá sustituirlos por valores
concretos que desee usar en la creación del autocomando.</p>
<p>En lugar de <code>autocmd</code>, se puede usar su versión abreviada:
<code>au</code>.</p>
<p>Para la creación de un autocomando con la API de Lua, que es como
suelo hacer ahora la configuración de Neovim, la función es</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">api</span><span class="op">.</span>nvim_create_autocmd<span class="op">(</span> <span class="op">{</span> <span class="op">&lt;</span><span class="va">evento</span><span class="op">&gt;</span> <span class="op">},</span> <span class="op">{</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">group</span> <span class="op">=</span> <span class="op">,</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">pattern</span> <span class="op">=</span> <span class="op">,</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">callback</span> <span class="op">=</span> <span class="op">,</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span></code></pre></div>
<p>Como ve, se tiene una tabla con eventos, aunque, si lo prefiere,
puede introducir uno solo que no esté en formato tabla. Por ejemplo,</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">api</span><span class="op">.</span>nvim_create_autocmd<span class="op">(</span><span class="st">&quot;FileType&quot;</span><span class="op">,</span> <span class="op">{</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<p>El argumento <code>&lt;group&gt;</code> se usa para poder activar o
desactivar de golpe varios autocomandos relacionados. Puede crear
autogrupos, que son identificativos de subconjuntos de autocomandos.
Para crear un autogrupo a la vieja usanza, se usa el comando
<code>:augroup</code>. Con la API de Lua es</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">api</span><span class="op">.</span>nvim_create_augroup<span class="op">(&lt;</span><span class="va">id_autogrupo</span><span class="op">&gt;,</span> <span class="op">{</span> <span class="op">&lt;</span><span class="va">opciones</span><span class="op">&gt;</span> <span class="op">})</span></span></code></pre></div>
<p>Algo que tiene que tener en cuenta es que, de forma predeterminada,
los comandos</p>
<p>Si desea consultar los eventos que tiene a su disposición, puede ir a
la <a
href="https://neovim.io/doc/user/autocmd.html#autocmd-events">entrada</a>
correspondiente en la documentación oficial.</p>
</section>
<section id="task-runners" class="level2">
<h2><em>Task runners</em></h2>
<p>También los llaman <em>task managers</em>.</p>
<p>Actualmente, existen dos <em>plug-ins</em> bastante populares a este
respecto. Creo que el mejor es <a
href="https://github.com/stevearc/overseer.nvim">Overseer</a>. También,
está <a
href="https://github.com/Shatur/neovim-tasks"><code>neovim-tasks</code></a>.</p>
</section>
</section>
<section id="lenguajes" class="level1">
<h1>Lenguajes</h1>
<section id="tex-y-sus-formatos" class="level2">
<h2>TeX y sus formatos</h2>
<p>Tal y como se explica en la gramática de TeX y LaTeX para Vim, en
<em>/usr/local/share/nvim/runtime/syntax/tex.vim</em>, cuando se tiene
un entorno <em>verbatim</em> cuyo resaltado se sale de sus límites, se
puede usar <code>%stopzone</code> para forzar la detención. Lo mismo,
con los entornos de matemáticas.</p>
<p>Vimtex es la mejor extensión actualmente de Neovim para TeX y sus
paquetes de macros (como, por ejemplo, LaTeX). No obstante, hay otras
basadas en LSP, como <a
href="https://github.com/latex-lsp/texlab">Texlab</a>.</p>
<p>Al instalar la extensión Vimtex, puede que Neovim le indique una
advertencia (<em>warning</em>) en <code>:checkhealth</code>. Se debe a
que no tiene <code>neovim-remote</code> instalado en su sistema. Es muy
fácil de instalar.</p>
<pre><code>$ pip3 install neovim-remote</code></pre>
<p>Luego, en su archivo de configuración de Neovim, deberá añadir</p>
<pre class="vim"><code>let g:vimtex_compiler_progname = &#39;nvr&#39;</code></pre>
</section>
</section>
<section id="plug-ins" class="level1">
<h1><em>Plug-ins</em></h1>
<p>En el mundo de Neovim (y Vim), llaman <em>plug-ins</em> a lo que en
otros editores llaman extensiones (<em>extensions</em>). TKTK.</p>
<p>Quizás, reciban este nombre porque, en lugar de ser muy completos,
son algo que nos sigue permitiendo hacer <em>scriptable</em> la
configuración del editor.</p>
<p>Tanto Vim como Neovim han seguido siempre una filosofía de ser muy
<em>hackeables</em>, por lo que no es raro que se haga uso de
<em>plug-ins</em> así como de ciertos <em>scripts</em> adaptados a su
configuración en particular.</p>
<p>Además, Neovim no suele adoptar muchas de las funcionalidades
modernas de los IDEs, como indicaciones visuales sobre los cambios en el
repositorio Git. Neovim suele centrarse más bien en las funcionalidades
de edición en el espíritu de las que tenía Vim en la época de
Moolenaar.</p>
<p>Debido a esto, casi con toda seguridad tendrá que usar algunos
<em>plug-ins</em>. Personalmente, trato de usar pocos, pues no me gusta
sobrecargarlo demasiado y, además, creo que tampoco suelo necesitar
tantas cosas. Para quien le gusta usar muchos <em>plug-ins</em>, por
ejemplo, porque desee que su editor sea más parecido a un
<em>full-blown</em> IDE, existen ciertas configuraciones que se pueden
instalar y en las que TKTK. El problema de estas es que quizás en algún
momento desee tratar de hacer algún ajuste muy específico. TKTK.</p>
<p>Debe saber también que existen algunos <em>plug-ins</em> que en
realidad son <em>packs</em> de <em>plug-ins</em>, como <a
href="https://github.com/echasnovski/mini.nvim"
class="plgin"><code>mini.nvim</code></a>, que ha alcanzado bastante
popularidad. Este cuenta con una serie de <em>plug-ins</em> que
implementan de forma básica (pero suficiente para la mayoría) muchos de
los <em>plug-ins</em> más populares.</p>
<p>Los gestores de <em>plug-ins</em> en Neovim han sido tradicionalmente
herramientas externas al propio editor. Sin embargo, Neovim (al igual
que Vim) incluye desde hace tiempo un sistema nativo de gestión de
paquetes (<code>:help packages</code>), a menudo llamado <q>packpath</q>
o simplemente <code>pack</code>. Este sistema es funcional pero muy
básico, y no gestiona automáticamente la descarga o actualización de
repositorios, lo que ha llevado a la popularidad de gestores de
<em>plug-ins</em> externos.</p>
<p>Para la versión 0.12 y futuras, se está desarrollando un gestor de
plugins nativo mucho más completo y avanzado. El objetivo es que este
nuevo gestor pueda manejar la instalación, actualización y carga de
plugins de forma automática, similar a como lo hacen herramientas como
<code>lazy.nvim</code> o <code>packer.nvim</code>, pero integrado
directamente en el núcleo de Neovim. Esto representa un paso importante
para mejorar la experiencia de serie del editor.</p>
<p>Puede obtener información sobre este en la ayuda oficial de Neovim
con el comando <code>:help vim.pack</code>. También, conviene que
consulte <code>:help packages</code>.</p>
<p>Por lo que se explica ahí, los <em>plug-ins</em> se instalan bajo el
directorio <em><code>$XDG_DATA_HOME</code>/share/nvim/site/pack</em>,
siendo, por ejemplo, en macOS, ese <code>$XDG_DATA_HOME</code> el
directorio <em>~/.local/share</em>. Los hay de dos tipos: tipo
<em>start</em> y tipo <em>opt</em>. Los primeros se cargan siempre al
iniciar Neovim; los otros, cuando se necesiten. Se incluyen en
directorios distintos, dentro de la ruta anterior. Normalmente, los
<em>plug-ins</em> suelen ser de este último tipo.</p>
<p>La forma de implementar los comandos a este respecto es mediante la
API <code>vim.pack</code> de Lua.</p>
<p>Básicamente, un <em>plug-in</em>, dentro del sistema de archivos no
es más que un repositorio de Git. Son bastante <q>crudos</q> a este
respecto.</p>
<p>Para actualizar los <em>plug-ins</em> instalados, se usa el comando
<code>:lua vim.pack.update()</code>. Se abrirá una pestaña con la
información sobre los cambios, pero no se habrá actualizado aún. Para
que se realicen estas actualizaciones, debe escribir el archivo; como
cualquier otro archivo, con <code>:write</code>. Luego puede cerrar la
pestaña con <code>:quit</code>.</p>
<p>Para eliminar <em>plug-ins</em>, se usa la función
<code>vim.pack.del()</code> de la API de Lua. Dentro debe incluir una
lista de cadenas con los nombres de los <em>plug-ins</em> que desea
eliminar. En cualquier caso, creo que no termina de eliminarlos del
directorio, por lo que termino comprobándolo por mí mismo y eliminando
esos repositorios en caso necesario.</p>
<hr />
<p>Algo que se incorporó a Neovim hace poco es que es muy sencillo
transformar a Lua un <em>plug-in</em> hecho en Vimscript. Gracias a
esto, podemos tener fácilmente los <em>plug-ins</em> de Vim. Por
ejemplo, son muy buenos los que crea el desarrollador <a
href="https://github.com/tpope">Tim Pope</a>. No obstante, muchos de los
<em>plug-ins</em> de Pope se han copiado en <em>packs</em> de
<em>plug-ins</em>, como <a
href="https://github.com/echasnovski/mini.nvim"
class="plgin"><code>mini.nvim</code></a>, por ejemplo</p>
<hr />
<p>¿Por qué prefiero usar pocos <em>plug-ins</em>, al contrario de lo
que hacen muchos? Soy más partidario de la filosofía de Tim Pope, es
decir, no tratar de reimplementar nada de Vim o Neovim. Simplemente,
adaptarme a este.</p>
<p>Hay gente que, al usar tantos <em>plug-ins</em>, termina haciendo un
uso muy diferente del editor TKTK.</p>
<p>Además, si usa muchos <em>plug-ins</em> y no llega a aprender
realmente a configurar Vim o Neovim, seguramente llegue el momento en el
que desee hacer un ajuste muy específico sobre algo y TKTK. En lugar de
aprender realmente a usar Vim o Neovim, se encontrará siempre copiando y
pegando cosas hechas por otros TKTK.</p>
<hr />
<p>Por qué usar Vim o Neovim a estas alturas, cuando existen muchas
herramientas gráficas con un montón de cosas TKTK.</p>
<p>Hay quien prefiere hacer un uso minimalista de la edición y
desarrollo. Por ejemplo, puede ver <a
href="https://www.youtube.com/watch?v=iF4RvQq6yU0">este vídeo de Gary
Bernhardt</a>.</p>
<hr />
<p>Otra cosa que conviene hacer es comprobar con
<code>checkhealth lazy</code> TKTK.</p>
<section id="gestión-diy-de-plug-ins" class="level2">
<h2>Gestión DIY de <em>plug-ins</em></h2>
<p>La forma háztelo tú mismo (<em>do it yourself</em> o DIY) se
beneficia de las funcionalidades que se han añadido últimamente tanto en
Vim como Neovim para agrupar los <em>plugins</em> en paquetes
(<em>packages</em>, vea <code>:h packages</code>) y un comando para
cargar los <em>plugins</em> de un paquete.</p>
<p>Mucha gente piensa que Vim y Neovim tienen ahora un gestor de
<em>plugins</em> integrado (<em>built-in plugins manager</em>), pero no
es así.</p>
<p>Lo que hace ahora Vim de forma nativa es básicamente segregar los
<em>plugins</em> y gestionar el <em>runtimepath</em>.</p>
<p>La forma en la que la gente suele autogestionar sus plugins con estas
nuevas funcionalidades es haciendo uso de submódulos de Git.</p>
<p><a href="https://dev.to/iggredible/how-to-use-vim-packages-3gil"
class="uri">https://dev.to/iggredible/how-to-use-vim-packages-3gil</a></p>
</section>
</section>
<section id="otros" class="level1">
<h1>Otros</h1>
<section id="esquemas-de-colores" class="level2">
<h2>Esquemas de colores</h2>
<p>Lo que en el mundo de Vim llaman <em>esquemas de colores</em> es lo
mismo que se conoce normalmente como <em>temas</em> (<em>themes</em>) en
el ámbito del <em>software</em>.</p>
<p>La mejor explicación básica sobre <a
href="https://vi.stackexchange.com/a/2783">cómo aprender a crear
esquemas de colores</a> es esta.</p>
<p>Con lo que he investigado, ya sé cómo se crea la syntax highlighting
en Vim.</p>
<p>Lo mejor que puede hacer es consultar la entrada <code>syntax</code>
en la ayuda de Vim (<code>:h syntax</code>).</p>
<p>Los ficheros están bajo
<em><code>&lt;vim_runtime&gt;</code>/syntax/</em> (variable de entorno
<code>VIMRUNTIME</code>). Esos son los que vienen con la instalación.
Luego, puede usar otro, por ejemplo, uno hecho por usted. Deberá tenerlo
bajo <em>~/.config/nvim/syntax/</em>. Estos últimos tendrán precedencia
sobre los otros. También, puede que un paquete le instale otro fichero
de sintaxis, como, por ejemplo, el paquete <code>vimtex</code>.
Personalmente, antes veía como imprescindible usar <em>plugins</em> para
todo, pero últimamente me he dado cuenta de que no son tan necesarios.
Vim y Neovim tienen muchas funcionalidades sin necesidad de
<em>plugins</em>, aunque no se lo parezca al principio.</p>
<p>En la documentación de VSCode, vi que preferían no hablar de
<em>syntax highlighting</em>, creo que debido a que están usando también
la semántica en el coloreado. Por tanto, yo prefiero hablar de cada cosa
por separado: <em>colors</em> y <em>tokenization</em>.</p>
<p>Algo que me parece interesante explicar también aquí es una nueva
tecnología que sacó Microsoft, llamada Language Server Protocol (LSP),
que creo que consiste en que se tendrá un protocolo para convertir las
gramáticas de los lenguajes en un lenguaje estándar. Por ejemplo, el
parsing del compilador del lenguaje C se puede transformar en un fichero
de sintaxis que puede usarse en distintos editores e IDEs. De momento,
creo que no se está usando, pues es una tecnología que tiene poco
tiempo, pero espero con impaciencia su llegada. En principio, la idea de
LSP era para usarse en el completion, linting, etc., pero no tenían
intención de usarlo para el coloreado. Por lo que he visto, en su
repositorio de GitHub (el de LSP) lo pidieron y creo que tienen
intención de que se le pueda dar también ese uso. Aunque están saliendo
plugins para integrar el LSP en Vim y Neovim, para Neovim están
integrando el LSP de forma nativa. Aun así, <a
href="https://jdhao.github.io/2019/11/20/neovim_builtin_lsp_hands_on/">creo
que es pronto aún para instalarlo</a>.</p>
<p>Para el resaltado de código, existe un proyecto de unificarlo para
todos los editores, llamado Tree-Sitter, que puede que esté muy
bien.</p>
</section>
<section id="ctags" class="level2">
<h2>Ctags</h2>
<p>Las ctags son unas etiquetas que pueden usarse en un proyecto de
<em>software</em> que esté editando. Lo que le permiten es moverse por
el código fácilmente, por ejemplo, si se encuentra en una llamada a una
clase, puede moverse fácilmente a la definición de esa clase, aunque se
encuentre en otro archivo del proyecto.</p>
<p>Deberá tener instalado el paquete de <em>software</em> <a
href="TKTKTKTKTKTKTKTK"><code>ctags</code></a>. Por ejemplo, para macOS,
está en Homebrew:</p>
<pre><code>$ brew install ctags</code></pre>
<p>Una vez que lo tenga instalado, para ir a la definición de un token
sobre el que tenga el cursor, deberá usar la combinación <kbd>^]</kbd>
(control cierre de corchete). Luego, puede moverse por la lista dando
saltos con <kbd>^o</kbd> y <kbd>^i</kbd> para ir atrás y adelante.</p>
<p>Puede ver también aquí <a
href="https://andrew.stwrt.ca/posts/vim-ctags/">una explicación de las
ctags</a>.</p>
<p>Creo que actualmente las ctags están siendo superadas por las
funcionalidades que otorgan los servidores de lenguajes (LSP).</p>
</section>
<section id="dap" class="level2">
<h2>DAP</h2>
<p>El DAP es como la funcionalidad que se tiene en los IDEs para hacer
un seguimiento de los valores de las variables en tiempo de ejecución.
Es algo que sirve para depuración (<em>debugging</em>). En realidad, es
algo que para terminal no tiene mucho sentido y es excesivamente
complicado; lo normal es usarlo en editores o IDEs de tipo GUI.</p>
<p>Además, hay quien no lo valora a este tipo de funcionalidades.</p>
<p>También, siempre puede hacer algo similar con enunciados
<code>print()</code> (o el equivalente en su lenguaje). Es preferible
crear unos buenos <em>tests</em>, con lo que se hace innecesaria la
depuración mediante DAP.</p>
</section>
<section id="herramientas" class="level2">
<h2>Herramientas</h2>
<p>Como cualquier otro editor de textos o IDE, Neovim tiene herramientas
que sirven para hacer más cómoda la edición. Además, con extensiones, se
pueden añadir otras herramientas con este propósito.</p>
<p>Algunas de las funciones de las que hablo son las siguientes:</p>
<ul>
<li><p><em>Análisis estático</em> – (<em>linting</em>). Muestra los
errores (<em>errors</em>) y advertencias (<em>warnings</em>) sobre el
código.</p></li>
<li><p><em>Autocompletado</em> – (<em>code-completion</em>). Muestra
cómo puede terminar una palabra que esté escribiendo. También se
incluirían aquí los retazos (<em>snippets</em>) básicos del
lenguaje.</p></li>
<li><p><em>Ir a definición</em> – (<em>go-to-definition</em>). Te mueve
a la definición de una función o un método. Vim tiene implementada una
herramienta similar (no con LSP) sin necesidad de extensiones.</p></li>
<li><p><em>Formateador</em> – (<em>formatter</em>). Se le especifican
algunos parámetros de estilo, como, por ejemplo, la longitud de las
líneas, la distancia en líneas en blanco entre las distintas partes del
código, etc., y, cuando se le indique, lo transforma. Un ejemplo es la
famosa extensión <a href="https://prettier.io/">Prettier</a>, para los
lenguajes de la web, como HTML, CSS, JSON, Markdown, etc. También los
llaman <em>code formatter</em> y <em>format runner</em>.</p></li>
</ul>
<p>Actualmente, el formateador de código que más se suele usar para
Python es <a href="https://github.com/psf/black">Black</a>.</p>
<p>Es muy relevante un proyecto que inició Microsoft sobre 2017, el <a
href="TKTKTKTKTKTK">Language Server Protocol</a> (LSP), que pretende
unificar las extensiones de los distintos editores en uno solo. Por
ejemplo, para el <em>linting</em>, autocompletado, formateador, etc., de
Python, tendríamos un solo servidor —por ejemplo, <a
href="https://github.com/python-lsp/python-lsp-server"><code>python-lsp-server</code></a>—,
hecho en Python, y esta serviría para todos los editores o IDEs, siempre
y cuando tengan un cliente de LSP. Esto unifica el esfuerzo para cada
lenguaje en un solo servidor, en lugar de tener que hacer una extensión
para cada editor o IDE.</p>
<p>Antes de la versión 0.5 de Neovim, la gente usaba ciertas extensiones
para tener esa funcionalidad, como ALE y Coc. Ahora, con Neovim 0.5, no
es necesario. Aun así, creo que se deben instalar extensiones para poder
usar LSP; tengo que investigar un poco TKTK.</p>
<p>Además de una extensión que le dé compatibilidad con LSP, necesita
instalar las herramientas de LSP para los lenguajes que vaya a usar en
su sistema.</p>
<p>Además, algunas de estas extensiones se limitan a proporcionarle la
funcionalidad con LSP pero no le proporcionan autocompletado. Esto
sucede, por ejemplo, con LanguageClient-neovim. Deberá completarlo con
una extensión que le permita tener autocompletado, como, por ejemplo,
Deoplete. Mucha gente opta por otra opción: instalar una extensión que
le proporcione ambas funcionalidades, como, por ejemplo
<code>coc</code>, que está alcanzando últimamente mucha fama en el mundo
de Vim.</p>
</section>
<section id="configuración" class="level2">
<h2>Configuración</h2>
<p>He de reconocer que no fue hasta hace relativamente poco que me di
cuenta de que la configuración de Vim y de VSCode no son tan distintas.
En Vim, tenemos un archivo <em>.vimrc</em>, que se escribe en lenguaje
Vimscript, donde se especifican los <em>plug-ins</em> que le cargamos,
ajustes de Vim y ajustes de las extensiones. Algunos de los ajustes se
podrían considerar extensiones en sí mismos.</p>
<p>Por cierto, en Neovim han cambiado algunas cosas. El archivo de
configuración suele ser <em>init.vim</em>. Además, el lenguaje que
emplea el archivo de configuración puede ser, a partir de la versión
0.5, si lo prefiere, un archivo Lua, en cuyo caso será
<em>init.lua</em>. Actualmente, en la versión 10, lo normal es ya que la
gente que usa Neovim haga su configuración principalmente con la API de
Lua, en lugar de con Vimscript, salvo en las partes en las que no se
pueda.</p>
<p>Una diferencia de Vim y Neovim con la mayoría de los IDEs es que en
los primeros la configuración, además de declarativa, puede ser
escriptable (<em>scriptable</em>). Así, además de poder especificar
cosas básicas contempladas por el editor como el uso de espacios o
<em>tabs</em>, en estos puede crear sus propias configuraciones.</p>
<p>En los otros, lo que no se pueda configurar quizás pueda lograrse con
el uso de alguna extensión. Si no encuentra una extensión para una
funcionalidad que desee, puede crearla usted mismo, pero esto lleva más
trabajo que implementarla en un <em>script</em> en la configuración de
Vim o Neovim.</p>
<p>El lenguaje de <em>scripting</em> para la configuración de Vim es
Vimscript, que es un lenguaje creado <em>ad hoc</em> para dicho
proyecto. Tal y como hemos explicado en otras ocasiones en este
documento, la filosofía de Neovim es más de delegar las cosas que se
puedan delegar a otros proyectos. A este respecto, están sustituyendo
Vimscript por Lua, un lenguaje minimalista que es muy cómodo de integrar
TKTK.</p>
<p>Este razonamiento tiene bastante sentido ya que crear un lenguaje
propio paralelamente a la creación de un editor supone una pérdida de
recursos destinados al desarrollo del editor.</p>
<p>La contrapartida de tener configuraciones escriptables está en que,
si no se sabe bien lo que se hace, puede suponer una amenaza para la
seguridad del sistema. Así, por ejemplo, tal y <a
href="https://github.com/neovim/neovim/issues/5784#issuecomment-506993689">como
recomienda Justin Keyes</a>, es mejor que Neovim no tenga soporte para
que se tengan configuraciones específicas de proyecto. Siempre puede
especificar ajustes específicos para un proyecto en su configuración
general especificando la ruta en la que se encuentra el proyecto. El
problema estaría en que cualquiera pudiese tocar dicha configuración y
crear o modificar <em>scripts</em> que luego ejecutará su ejecutable de
Neovim.</p>
<p>En Vim, ha existido durante mucho tiempo una funcionalidad llamada
<em>modeline</em> TKTK.</p>
<p>No obstante, existe una especificación universal sobre ajustes
básicos de edición llamada EditorConfig, para la que Neovim trae soporte
de serie. Son ajustes básicos que se especifican de forma declarativa en
un archivo <em>.editorcofig</em> ubicado en la raíz del proyecto.</p>
</section>
<section id="demasiado-eficiente" class="level2">
<h2>Demasiado eficiente</h2>
<p>Aunque a quienes nos gusta programar solemos tener el impulso de
pensar que lo ideal sería que todo fuese programable, esto quizás no
tiene mucho sentido para ciertos ámbitos. Pensemos, por ejemplo, en TeX
y LaTeX. TeX es el lenguaje que se suele usar para artículos académicos
y libros de texto en ciertas áreas de la ciencia y la tecnología;
matemáticas, física y ciencias de la computación, principalmente. Es un
lenguaje de marcado (<em>mark-up language</em>), pero, al contrario que
otros lenguajes de marcado, como, por ejemplo, HTML, TeX es un lenguaje
Turing-completo, es decir, que se puede considerar que es un lenguaje de
programación. ¿Esto es bueno? Para ciertas cosas sí y para otras no. Por
ejemplo, le permite crear sus propios comandos y macros; o sea, tiene
integrada la abstracción procedimental (lo que más comúnmente se llama
<em>funciones</em>): puede reutilizar código, etc. Lo malo es que, si le
doy un programa a alguien para que compile el documento a partir de las
fuentes, al compilarlo podrá estar ejecutando en su sistema código que
puede que sea peligroso. Por el contrario, otros lenguajes menos
<q>programables</q> —es decir, que no son Turing-completos— y que sirven
para hacer documentos, como, por ejemplo, HTML —o Markdown, que podría
considerarse una versión simplificada de este—, le obligarán a crear un
documento de una forma algo menos eficiente, pero tendrá la seguridad de
que no ejecutará código arbitrario en su sistema, es decir, será más
seguro.</p>
<p>Para la parte de los documentos que se conoce como el cuerpo del
texto (<em>body text</em>), no hay diferencia. Quizás, con TeX y LaTeX
se pueda agilizar algo, pero la diferencia no será muy apreciable. Donde
sí se puede sacar mayor provecho de TeX y LaTeX es en que le permiten
hacer, sin demasiado esfuerzo, figuras y otro tipo de cosas
TKTKTKTKTKTKTK de textos técnicos.</p>
<p>Creo que existen varias soluciones a esto. Por ejemplo, ejecutar el
código en algún entorno aislado, como una VM o un contenedor, o incluso
en el propio servidor de GitHub, que ahora se puede.</p>
<p>Otra, que me gusta algo menos, sería dar el documento final de solo
lectura, como el archivo PDF, por ejemplo. No me gusta porque hay veces
en que el documento es <em>open source</em> y está pensado para
colaboraciones, con lo que los colaboradores deberían, en principio,
tener las fuentes y ejecutarlas en sus máquinas.</p>
</section>
<section id="neovim-vs.-shell" class="level2">
<h2>Neovim <em>vs.</em> <em>shell</em></h2>
<p>También, algo en lo que a veces entra en conflicto el editor Vim es
con el <em>shell</em>. Quiero decir que hay cosas que la gente la hace
en Vim cuando sería más adecuado hacerla en el <em>shell</em>.</p>
<p>Hay gente que está tratando de impulsar de nuevo el uso de
herramientas de <em>shell</em>, tanto de tipo CLI como TUI. Por ejemplo,
la empresa <a href="https://charm.sh/">Charm</a>.</p>
<p>Lo cierto es que, cuando lo basas todo en un editor, tal y como ya ha
sucedido con Emacs, pierdes en cierto modo la composabilidad que otorgan
el <em>software</em> de <em>shell</em>. Me refiero a la filosofía de
Unix. Y Neovim parece que va por ese camino, al impulsar tanto la
creación de <em>plug-ins</em>.</p>
</section>
<section id="neovim-vs.-vscode" class="level2">
<h2>Neovim <em>vs.</em> VSCode</h2>
<p>Tengo la sensación de que tampoco se puede mejorar ya mucho de Vim.
Hay quien piensa que esto es bueno. Es como tocar un instrumento: la
guitarra es un instrumento muy antiguo y no ha sufrido muchos cambios;
quizás, el más relevante sea el uso de la electrificación y la
distorsión. Y, aun así, queda muchísimo para que saquemos todas sus
posibilidades, si es que eso llega a ocurrir.</p>
<p>Imagino que esto es lo que piensa la gente que hace un uso bastante
minimalista de Vim y usan muy pocos <em>plug-ins</em>. Lo cierto es que
el uso de Vim sin extensiones sigue siendo una auténtica pasada. Mucha
gente no es consciente de que muchas de las cosas que hace mediante el
uso de <em>plug-ins</em> podría hacerlas sin estos, pues Vim otorga
muchas posibilidades.</p>
<p>La eficiencia, en ciertos ámbitos, creo que está sobrevalorada. Es
mejor los efectos de red.</p>
<p>Últimamente, he estado pensando que quizás Vim y Neovim no tienen
tanto futuro. Hay otros editores que parece que le superan en ciertas
cosas que se pueden considerar básicas y que Vim y Neovim no tienen aún
resueltas. Por ejemplo, en el resaltado de código. Creo que las
gramáticas de TextMate son mejores, y VSCode va aún más allá al
implementar el resaltado semántico (<em>semantic highlight</em>).
Quizás, esto se solucione si las gramáticas de Tree-Sitter terminan
obteniendo una gran calidad. Bueno, en realidad, las gramáticas de
Tree-Sitter no pueden entregar resaltado semantico, sino solo
sintáctico. Aun así, en Neovim están trabajando para tener resaltado
semántico también de serie.</p>
<p>Esto tiene relación también con lo que explica Nadia Eghbal en su
libro TKTKTKTKTKTKTK<a href="#fn11" class="footnote-ref" id="fnref11"
role="doc-noteref"><sup>11</sup></a></p>
</section>
<section id="plantillas" class="level2">
<h2>Plantillas</h2>
<p>Se puede configurar Vim para que tenga funcionalidad de <a
href="https://shapeshed.com/vim-templates/">crear y usar plantillas</a>
(<em>templates</em>).</p>
</section>
<section id="configuración-para-todo-el-sistema" class="level2">
<h2>Configuración para todo el sistema</h2>
<p>El archivo de configuración para todo el sistema
(<em>systemwide</em>), al usar Neovim, es
<em>/etc/xdg/nvim/sysinit.vim</em>, solo para Linux. De todos modos, no
conviene hacer esto, es decir, es preferible que cada usuario tenga su
archivo de configuración propio. Creo que nadie suele hacer ya esto. De
hecho, las configuraciones <em>systemwide</em> creo que se están dejando
ya como un vestigio del pasado, ahora que puedes descargarte tus
configuraciones de un repositorio de GitHub.</p>
</section>
<section id="concealing" class="level2">
<h2><em>Concealing</em></h2>
<p>En cuanto al estilo de programación, no me gusta usar caracteres
Unicode en el código. Me refiero a los que sean distinto a los
caracteres básicos en español.</p>
<p>Aunque las herramientas de JavaScript suelan traer normalizadores de
Unicode (<em>Unicode normalizers</em>), prefiero usar como regla de
estilo que se use sólo caracteres básicos del español; nada de símbolos
matemáticos como pi, emojis, etc.</p>
<p>Es más, en caso de que tenga que introducir algún símbolo extraño del
programa, prefiero especificarlo con una secuencia de escape (<em>escape
sequence</em>), como, por ejemplo, <code>\u00e9</code> o
<code>\u{E9}</code>.</p>
<p>Creo que a eso lo llaman <em>text concealling</em>. También, recibe
otros nombres.</p>
</section>
<section id="editar-documentación" class="level2">
<h2>Editar documentación</h2>
<p>Para el lenguaje Markdown, existe un <em>plug-in</em> llamado <a
href="https://github.com/iamcco/markdown-preview.nvim"><code>markdown-preview.nvim</code></a>
que permite que se abra un navegador web y se pueda previsualizar la
salida del documento Markdown en formato web, además de sincronizarse
con la parte del <em>buffer</em> que se está editando en la ventana en
Neovim. Lo cierto es que tiene bastante buena pinta.</p>
<p>En realidad, tampoco es algo que sea importante, pues, al tratrse de
un LML, es bastante cómodo de leer directamente en el código fuente.</p>
</section>
<section id="gestión-minimalista-de-archivos" class="level2">
<h2>Gestión minimalista de archivos</h2>
<p>Aunque durante bastante tiempo he hecho uso del gestor de archivos
(<em>file manager</em>) que trae de serie Neovim, que es Netrw<a
href="#fn12" class="footnote-ref" id="fnref12"
role="doc-noteref"><sup>12</sup></a>, y posteriormente lo sustituí por
otros con más funcionalidades y más coherencia, como es el
<em>plug-in</em> <code>oil.nvim</code>, ahora me he pasado a un manejo
más minimalista y ni siquiera uso ya Netrw. Además de por minimalismo,
también lo hago porque el gestor de archivos ocupa un <em>buffer</em> y
termina entorpeciendo un poco el uso que hago de los comandos para
moverme rápido entre estos.</p>
<p>Lo primero es indicar cómo se deshabilita Netrw, ya que, de forma
predeterminada, viene habilitado.</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="va">vim</span><span class="op">.</span><span class="va">g</span><span class="op">.</span><span class="va">loaded_netrwPlugin</span> <span class="op">=</span> <span class="dv">0</span></span></code></pre></div>
<p>Básicamente, lo que hago es un mayor uso del comando
<code>:edit</code>, de Ex; o, más bien, su forma abreviada:
<code>:e</code>. Así es como me muevo y voy progresando por el sistema
de archivos. Esto lo hago junto con la tecla tabuladora para ir
autocompletando. Por ejemplo, <code>:e lu</code>. Pulso <kbd>Tab</kbd>
para que autocomplete. Entonces, se rellena hasta <code>:e lua/</code>.
Ahora, para seguir progresando dentro de dicha carpeta, pongo un
asterisco, <code>:e lua/*</code> y luego pulso otra vez <kbd>Tab</kbd>,
y me sigue mostrando las opciones.</p>
<p>Luego, para ir para atrás, con <kbd>Ctrl</kbd> + <kbd>w</kbd> vamos
eliminando rápidamente las partes del sistema de archivos que se han
autocompletado.</p>
<p>Algo que también se debería tener en cuenta es que, por comodidad,
quizás le interese abrir <em>buffers</em> de todos los archivos en una
carpeta, o los que sean de cierto tipo dentro de la misma, haciendo uso
de comodines (<em>wildcards</em>). Si intenta abrirlos con el comando
<code>:edit</code>, por ejemplo, con algo como
<code>:e after/ftplugins/*.lua</code>, no le dejará hacerlo y le
mostrará un error. Deberá usar, en su lugar, el comando
<code>:next</code>. En este ejemplo,
<code>:next after/ftplugins/*.lua</code>. En cualquier caso, tampoco es
algo que se recomiende. Quizás sea mejor ir abriéndolos uno a uno. Otra
cosa sería que desease realizar una acción, de un solo golpe, sobre
muchos archivos, cosa que se haría con la lista de argumentos de
Neovim.</p>
<p>A la hora de eliminar esos <em>buffers</em>, la forma sería con
<code>:bdelete after/ftplugins/*.lua</code>, pero, si pulsa <span
class="kbs">Intro</span> ahí, tampoco le dejará. En su lugar, lo que
debe hacer es expandir el comodín (<em>wildcard</em>) para que se
expanda la expresión y se pongan todas. Esto se hace con el atajo de
teclado <kbd>Ctrl</kbd> + <kbd>a</kbd>.</p>
<p>También, en lugar de añadir una secuencia de dos asteriscos
(<code>**</code>) a la variable <code>path</code>, creo que es mejor ir
añadiendo las carpetas que deseemos o eliminándolas, tal y <a
href="https://www.reddit.com/r/vim/comments/8mi8cm/is_using_in_path_a_good_idea/">como
explican aquí</a>. Por ejemplo,</p>
<pre class="vim"><code>set path+=lua</code></pre>
<p>o, si prefiere con Lua,</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode lua"><code class="sourceCode lua"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span><span class="va">lua</span> <span class="va">vim</span><span class="op">.</span><span class="va">opt</span><span class="op">.</span><span class="va">path</span><span class="op">:</span>append <span class="st">&quot;lua&quot;</span></span></code></pre></div>
<p>solo que esta última forma lleva más trabajo.</p>
<p>No solo serviría para usar el comando <code>:find</code>, sino que
también vendría bien para hacer más cómoda la selección de ciertas
partes. TKTK.</p>
<p>También, se puede ir moviendo usando el comando <code>cd</code>, pero
el de Neovim; no el del <em>shell</em>. Así, irá centrándose en las
distintas carpetas y, cuando lo desee, pasar al directorio
principal.</p>
<p>Por ejemplo, puede usar el comando <code>:edit</code> para ver lo que
hay y, si quiere centrarse en una carpeta en concreto, con
<kbd>Esc</kbd> sale sin terminar de seleccionar una ruta y pasa a
seleccionarla con <code>:cd</code>.</p>
<p>También, voy haciendo uso de las ventanas del terminal para que así
tenga ordenado de forma lógica TKTK. Dentro de una misma área temática,
que, como digo, corresponde a una misma ventana, hago las divisiones en
etiquetas (<em>tags</em>) de terminal.</p>
<p>Con la combinación de teclas <kbd>Cmd</kbd> + <kbd>Shift</kbd> +
<kbd>i</kbd>, en el terminal predeterminado de macOS, nos permite
renombrar los títulos de las ventanas (bueno, en realidad, de las
pestañas de estas TKTK). Conviene también modificar el perfil
(<em>profile</em>) en concreto. En la pestaña <em>Window</em>, para que
no muestre de forma automática el comando.</p>
<p>Tengo que investigar cómo se crean perfiles y cómo se pueden
usar.</p>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Quizás, esta expresión, que la he leído en la propia
documentación oficial de Neovim, sea algo desacertada, pues los otros
editores tienen un modo. Bueno, o quizás no; según se mire.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Esto contrasta, por ejemplo, con la filosofía de los
sistemas Windows, que, en lugar de mediante archivos de configuración,
la administración se suele hacer mediante el Registro del sistema.<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Una forma de calificar al desarrollador principal de un
proyecto de <em>software</em> con licencia <em>open source</em>
(incluyendo aquí también a las de <em>software</em> libre, <em>free
software</em>) que lo maneja con <q>mano de hierro</q>, sobretodo cuando
él (o ella) ha sido el creador inicial del mismo, es decir que se trata
de un <em>dictador benevolente de por vida</em> (<em>benevolent dictator
for life</em>), o por sus siglas: BDFL.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Esto lo menciona la profesora de diseño web en el MIT
Lua Verou. TKTK. También, es de destacar que esta es la filosofía que
suele seguir la empresa Apple con sus productos. TKTK.<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>De hecho, en Vim, al principio no era posible la
creación de <em>plug-ins</em>. Es algo que añadió Moolenaar TKTK.<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>En realidad, en Neovim se pueden crear <em>plug-ins</em>
tanto en Vimscript como en Lua, aunque lo usual suele ser en Lua. En
Vim, sin embargo, solo en Vimscript.<a href="#fnref6"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>También se podría decir <em>suceso</em>.<a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Aunque muchas veces a los símbolos de exclamación
(<q>¡</q> y <q>!</q>) los llamen <em>signos de admiración</em>, creo que
es una designación desacertada.<a href="#fnref8" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Esta es otra de las cosas que no me gustan del modo Vi
de la mayoría de editores de texto. Si deja pulsada una tecla, no sigue
actuando, sino que actúa una sola vez por pulsación. No sé por qué hacen
esto. Imagino que se solucionará cuando se pueda usar el modo Vim
mediante Neovim.<a href="#fnref9" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>En otros editores, como, por ejemplo, VS Code, lo
llaman <em>selección rectangular</em> (<em>rectangular
selection</em>).<a href="#fnref10" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>De hecho, si algo he sacado en claro tras leer el libro
es que los que contribuyen actualmente al <em>open source</em> son gente
menos ideologizada y más práctica. Lo que quieren es que puedan
contribuir de un modo más cómodo.<a href="#fnref11"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>En realidad, Netrw no es una funcionalidad como la
mayoría de las que vienen de serie con Neovim, sino que es un
<em>plug-in</em>, pero uno que viene de serie en este.<a href="#fnref12"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<!--</main>-->
</body>
</html>
